"use strict";(self.webpackChunkrunar_docs=self.webpackChunkrunar_docs||[]).push([[771],{3738:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"features/encryption-schema","title":"Runar Encryption Schema","description":"This document describes the comprehensive encryption system in Runar, including the PKI infrastructure, envelope encryption, and selective field encryption capabilities.","source":"@site/docs/features/encryption-schema.md","sourceDirName":"features","slug":"/features/encryption-schema","permalink":"/rust-docs/docs/features/encryption-schema","draft":false,"unlisted":false,"editUrl":"https://github.com/runar-labs/runar-rust/tree/main/rust-docs/markdown/docs/features/encryption-schema.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Example Service Implementation","permalink":"/rust-docs/docs/services/example-service"},"next":{"title":"Enhanced Serialization with Selective Field Encryption","permalink":"/rust-docs/docs/features/enhanced-serialization"}}');var t=r(4848),s=r(8453);const l={},o="Runar Encryption Schema",a={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"PKI Infrastructure",id:"pki-infrastructure",level:2},{value:"Certificate Hierarchy",id:"certificate-hierarchy",level:3},{value:"Certificate Workflow",id:"certificate-workflow",level:3},{value:"Phase 1: CA Initialization",id:"phase-1-ca-initialization",level:4},{value:"Phase 2: Node Certificate Issuance",id:"phase-2-node-certificate-issuance",level:4},{value:"Phase 3: QUIC Transport Setup",id:"phase-3-quic-transport-setup",level:4},{value:"Implementation Details",id:"implementation-details",level:3},{value:"Key Management",id:"key-management",level:2},{value:"Key Classes",id:"key-classes",level:3},{value:"Key Derivation",id:"key-derivation",level:3},{value:"Key Storage and Security",id:"key-storage-and-security",level:3},{value:"Envelope Encryption",id:"envelope-encryption",level:2},{value:"Envelope Structure",id:"envelope-structure",level:3},{value:"Encryption Process",id:"encryption-process",level:3},{value:"Decryption Process",id:"decryption-process",level:3},{value:"Example Usage",id:"example-usage",level:3},{value:"Selective Field Encryption",id:"selective-field-encryption",level:2},{value:"Field Annotation",id:"field-annotation",level:3},{value:"Label Resolution",id:"label-resolution",level:3},{value:"Encryption Groups",id:"encryption-groups",level:3},{value:"Serialization Process",id:"serialization-process",level:3},{value:"Access Control",id:"access-control",level:3},{value:"End-to-End Encryption Flow",id:"end-to-end-encryption-flow",level:2},{value:"Complete Setup Flow",id:"complete-setup-flow",level:3},{value:"Data Sharing Example",id:"data-sharing-example",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Key Separation",id:"key-separation",level:3},{value:"Forward Secrecy",id:"forward-secrecy",level:3},{value:"Compromise Impact",id:"compromise-impact",level:3},{value:"Backup and Recovery",id:"backup-and-recovery",level:3},{value:"API Reference",id:"api-reference",level:2},{value:"Mobile Key Manager",id:"mobile-key-manager",level:3},{value:"Node Key Manager",id:"node-key-manager",level:3},{value:"Serializer Registry",id:"serializer-registry",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"runar-encryption-schema",children:"Runar Encryption Schema"})}),"\n",(0,t.jsx)(n.p,{children:"This document describes the comprehensive encryption system in Runar, including the PKI infrastructure, envelope encryption, and selective field encryption capabilities."}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pki-infrastructure",children:"PKI Infrastructure"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#key-management",children:"Key Management"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#envelope-encryption",children:"Envelope Encryption"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#selective-field-encryption",children:"Selective Field Encryption"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#end-to-end-encryption-flow",children:"End-to-End Encryption Flow"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#security-considerations",children:"Security Considerations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#api-reference",children:"API Reference"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Runar implements a comprehensive encryption system that provides:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"PKI Infrastructure"}),": X.509 certificate-based identity and authentication"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Envelope Encryption"}),": Multi-recipient encryption for cross-device data sharing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Selective Field Encryption"}),": Field-level encryption with label-based key resolution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mobile Key Management"}),": Self-custodied keys with mobile wallet integration"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The system is designed for end-to-end encryption where data remains encrypted from producer to consumer, with keys managed by users through their mobile devices."}),"\n",(0,t.jsx)(n.h2,{id:"pki-infrastructure",children:"PKI Infrastructure"}),"\n",(0,t.jsx)(n.h3,{id:"certificate-hierarchy",children:"Certificate Hierarchy"}),"\n",(0,t.jsx)(n.p,{children:"Runar uses a hierarchical PKI system with the following structure:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Mobile User CA (Self-signed root certificate)\n\u2514\u2500\u2500 Node TLS Certificate (signed by Mobile CA)\n    \u2514\u2500\u2500 Used for all QUIC/TLS operations\n"})}),"\n",(0,t.jsx)(n.h3,{id:"certificate-workflow",children:"Certificate Workflow"}),"\n",(0,t.jsx)(n.h4,{id:"phase-1-ca-initialization",children:"Phase 1: CA Initialization"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mermaid",children:"flowchart TD\n    A[Mobile App Start] --\x3e B[Generate ECDSA P-256 Key Pair]\n    B --\x3e C[Create Self-signed CA Certificate]\n    C --\x3e D[CA Ready to Issue Certificates]\n"})}),"\n",(0,t.jsx)(n.h4,{id:"phase-2-node-certificate-issuance",children:"Phase 2: Node Certificate Issuance"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mermaid",children:"sequenceDiagram\n    participant M as Mobile CA\n    participant N as Node\n    \n    N->>N: Generate ECDSA key pair\n    N->>N: Create PKCS#10 CSR\n    N->>M: Send CSR in setup token\n    M->>M: Validate CSR\n    M->>M: Sign CSR with OpenSSL\n    M->>M: Create X.509 certificate\n    M->>N: Send certificate + CA cert\n    N->>N: Install and validate certificates\n    N->>N: Ready for QUIC transport\n"})}),"\n",(0,t.jsx)(n.h4,{id:"phase-3-quic-transport-setup",children:"Phase 3: QUIC Transport Setup"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mermaid",children:"sequenceDiagram\n    participant N1 as Node 1\n    participant N2 as Node 2\n    \n    Note over N1,N2: Both nodes have certificates from same CA\n    \n    N1->>N2: QUIC connection with TLS handshake\n"})}),"\n",(0,t.jsx)(n.h3,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Algorithm"}),": ECDSA P-256 throughout the entire system"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Certificate Format"}),": Standard X.509 with proper extensions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CSR Format"}),": PKCS#10 Certificate Signing Requests"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Encoding"}),": DER encoding for all certificate storage and transmission"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Compliance"}),": Full compliance with RFC 5280 and related standards"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"key-management",children:"Key Management"}),"\n",(0,t.jsx)(n.h3,{id:"key-classes",children:"Key Classes"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Class"}),(0,t.jsx)(n.th,{children:"Purpose"}),(0,t.jsx)(n.th,{children:"Storage Location"}),(0,t.jsx)(n.th,{children:"Derivation"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"User Root Key"})}),(0,t.jsx)(n.td,{children:"Master key for mobile wallet"}),(0,t.jsx)(n.td,{children:"Mobile device (secure storage)"}),(0,t.jsx)(n.td,{children:"Random generation"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"User Profile Keys"})}),(0,t.jsx)(n.td,{children:"Personal/work/family profiles"}),(0,t.jsx)(n.td,{children:"Mobile device"}),(0,t.jsx)(n.td,{children:"Derived from root key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Node Storage Keys"})}),(0,t.jsx)(n.td,{children:"Local node encryption"}),(0,t.jsx)(n.td,{children:"Node (encrypted storage)"}),(0,t.jsx)(n.td,{children:"32-byte random"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Network Data Keys"})}),(0,t.jsx)(n.td,{children:"Cross-network sharing"}),(0,t.jsx)(n.td,{children:"Mobile + Node"}),(0,t.jsx)(n.td,{children:"Derived from root key"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Envelope Keys"})}),(0,t.jsx)(n.td,{children:"Ephemeral per-object"}),(0,t.jsx)(n.td,{children:"Generated on-demand"}),(0,t.jsx)(n.td,{children:"Ephemeral"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"key-derivation",children:"Key Derivation"}),"\n",(0,t.jsx)(n.p,{children:"Profile keys are derived using HKDF from the user root key:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// Example key derivation\nlet root_key = self.user_root_key.as_ref()?;\nlet root_key_bytes = root_key.private_key_der()?;\nlet hk = Hkdf::<Sha256>::new(None, &root_key_bytes);\n\nlet info = format!("runar-profile-{}", profile_id);\nlet mut derived_key = [0u8; 32];\nhk.expand(info.as_bytes(), &mut derived_key)?;\n'})}),"\n",(0,t.jsx)(n.h3,{id:"key-storage-and-security",children:"Key Storage and Security"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"User Root Keys"}),": Stored in mobile device secure storage (Keychain/Keystore)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Profile Keys"}),": Derived on-demand, never stored persistently"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Network Keys"}),": Encrypted and distributed to authorized nodes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Node Keys"}),": Encrypted with node's storage key"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"envelope-encryption",children:"Envelope Encryption"}),"\n",(0,t.jsx)(n.p,{children:"Envelope encryption provides multi-recipient access control for cross-device data sharing."}),"\n",(0,t.jsx)(n.h3,{id:"envelope-structure",children:"Envelope Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct EnvelopeEncryptedData {\n    pub encrypted_data: Vec<u8>,           // AES-GCM encrypted payload\n    pub network_id: String,                // Network identifier\n    pub network_encrypted_key: Vec<u8>,    // Network key encrypted with node key\n    pub profile_encrypted_keys: HashMap<String, Vec<u8>>, // Profile keys encrypted with user keys\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"encryption-process",children:"Encryption Process"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Generate Ephemeral Key"}),": Create a random AES-256 key for the data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Encrypt Data"}),": Use AES-GCM to encrypt the payload with the ephemeral key"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Encrypt for Network"}),": Encrypt the ephemeral key with the network key"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Encrypt for Profiles"}),": Encrypt the ephemeral key with each profile's public key"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Assemble Envelope"}),": Combine all encrypted components"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"decryption-process",children:"Decryption Process"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Network Decryption"}),": Node decrypts ephemeral key using network key"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Profile Decryption"}),": Mobile decrypts ephemeral key using profile key"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Decryption"}),": Use ephemeral key to decrypt the payload"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-usage",children:"Example Usage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// Mobile side - encrypt data for network and profiles\nlet test_data = b"This is a test message that should be encrypted and decrypted";\nlet envelope = mobile.encrypt_with_envelope(\n    test_data,\n    &network_id,\n    vec!["personal".to_string(), "work".to_string()],\n)?;\n\n// Node side - decrypt using network key\nlet decrypted_by_node = node.decrypt_envelope_data(&envelope)?;\n\n// Mobile side - decrypt using profile key\nlet decrypted_by_mobile = mobile.decrypt_with_profile(&envelope, "personal")?;\n'})}),"\n",(0,t.jsx)(n.h2,{id:"selective-field-encryption",children:"Selective Field Encryption"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"runar-serializer"})," provides selective field encryption using label-based key resolution."]}),"\n",(0,t.jsx)(n.h3,{id:"field-annotation",children:"Field Annotation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[derive(Encrypt, serde::Serialize, serde::Deserialize, Debug, PartialEq, Clone)]\npub struct TestProfile {\n    pub id: String,\n    #[runar(user, system, search)]\n    pub name: String,\n    #[runar(user, system, search)]\n    pub email: String,\n    #[runar(user)]\n    pub user_private: String,\n    #[runar(user, system, search)]\n    pub created_at: u64,\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"label-resolution",children:"Label Resolution"}),"\n",(0,t.jsx)(n.p,{children:"Labels are resolved to cryptographic keys through a configurable resolver:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let mobile_label_config = KeyMappingConfig {\n    label_mappings: HashMap::from([\n        (\n            "user".to_string(),\n            LabelKeyInfo {\n                public_key: profile_pk.clone(),\n                scope: KeyScope::Profile,\n            },\n        ),\n        (\n            "system".to_string(),\n            LabelKeyInfo {\n                public_key: network_pub.clone(),\n                scope: KeyScope::Network,\n            },\n        ),\n    ]),\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"encryption-groups",children:"Encryption Groups"}),"\n",(0,t.jsx)(n.p,{children:"Fields with the same labels are grouped and encrypted together:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct EncryptedLabelGroup {\n    pub label: String,                    // The label this group was encrypted with\n    pub envelope: EnvelopeEncryptedData,  // Envelope-encrypted payload\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"serialization-process",children:"Serialization Process"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Field Grouping"}),": Group fields by their labels"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Label Resolution"}),": Resolve labels to cryptographic keys"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Envelope Encryption"}),": Encrypt each group using envelope encryption"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Serialization"}),": Serialize the encrypted structure"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"access-control",children:"Access Control"}),"\n",(0,t.jsx)(n.p,{children:"Different entities can access different fields based on their key access:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mobile with Profile Key"}),": Can decrypt ",(0,t.jsx)(n.code,{children:"user"})," and ",(0,t.jsx)(n.code,{children:"system"})," fields"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Node with Network Key"}),": Can decrypt ",(0,t.jsx)(n.code,{children:"system"})," and ",(0,t.jsx)(n.code,{children:"search"})," fields"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unauthorized Entity"}),": Cannot decrypt any fields"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"end-to-end-encryption-flow",children:"End-to-End Encryption Flow"}),"\n",(0,t.jsx)(n.h3,{id:"complete-setup-flow",children:"Complete Setup Flow"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mermaid",children:"sequenceDiagram\n    participant M as Mobile\n    participant N as Node\n    \n    Note over M,N: Initial Setup\n    M->>M: Generate user root key\n    M->>M: Create self-signed CA certificate\n    N->>N: Generate node key pair\n    N->>N: Create PKCS#10 CSR\n    N->>M: Send setup token (encrypted CSR)\n    M->>M: Process CSR and sign certificate\n    M->>N: Send certificate message (encrypted)\n    N->>N: Install certificate\n    \n    Note over M,N: Key Distribution\n    M->>M: Generate network data key\n    M->>N: Send network key message (encrypted)\n    N->>N: Install network key\n    \n    Note over M,N: Data Encryption\n    M->>M: Encrypt data with envelope encryption\n    M->>N: Send encrypted data\n    N->>N: Decrypt data using network key\n"})}),"\n",(0,t.jsx)(n.h3,{id:"data-sharing-example",children:"Data Sharing Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// 1. Mobile generates network key\nlet network_id = mobile.generate_network_data_key()?;\n\n// 2. Mobile creates network key message for node\nlet network_key_message = mobile.create_network_key_message(\n    &network_id, \n    &node_public_key\n)?;\n\n// 3. Node installs network key\nnode.install_network_key(network_key_message)?;\n\n// 4. Mobile encrypts data for sharing\nlet test_data = b"Shared data that should be encrypted";\nlet envelope = mobile.encrypt_with_envelope(\n    test_data,\n    &network_id,\n    vec!["personal".to_string()],\n)?;\n\n// 5. Node can decrypt the data\nlet decrypted = node.decrypt_envelope_data(&envelope)?;\nassert_eq!(decrypted, test_data);\n\n// 6. Mobile can also decrypt using profile key\nlet mobile_decrypted = mobile.decrypt_with_profile(&envelope, "personal")?;\nassert_eq!(mobile_decrypted, test_data);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,t.jsx)(n.h3,{id:"key-separation",children:"Key Separation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Signing vs Encryption"}),": Separate keys for different purposes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Profile Isolation"}),": Each profile has independent keys"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Network Isolation"}),": Network keys are isolated per network"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Node Isolation"}),": Node keys are local to each node"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"forward-secrecy",children:"Forward Secrecy"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Ephemeral Keys"}),": Envelope encryption uses ephemeral keys"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Key Rotation"}),": Network keys can be rotated"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Profile Rotation"}),": Profile keys can be re-derived"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"compromise-impact",children:"Compromise Impact"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"User Root Key"}),": Full account compromise"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Node Key"}),": Local node data compromise only"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Network Key"}),": Network data compromise only"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Profile Key"}),": Profile data compromise only"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"backup-and-recovery",children:"Backup and Recovery"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"User Root Key"}),": Must be backed up securely (seed phrase)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Profile Keys"}),": Re-derivable from root key"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Network Keys"}),": Re-derivable from root key"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Node Keys"}),": Local to node, not backed up"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,t.jsx)(n.h3,{id:"mobile-key-manager",children:"Mobile Key Manager"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct MobileKeyManager {\n    // Initialize with self-signed CA certificate\n    pub fn new(logger: Arc<Logger>) -> Result<Self>;\n    \n    // Generate user root key\n    pub fn initialize_user_root_key(&mut self) -> Result<Vec<u8>>;\n    \n    // Process node CSR and issue certificate\n    pub fn process_setup_token(&mut self, token: &SetupToken) -> Result<NodeCertificateMessage>;\n    \n    // Generate network data key\n    pub fn generate_network_data_key(&mut self) -> Result<String>;\n    \n    // Create network key message for node\n    pub fn create_network_key_message(&self, network_id: &str, node_id: &str) -> Result<NetworkKeyMessage>;\n    \n    // Derive user profile key\n    pub fn derive_user_profile_key(&mut self, profile_id: &str) -> Result<Vec<u8>>;\n    \n    // Envelope encryption\n    pub fn encrypt_with_envelope(&self, data: &[u8], network_id: &str, profile_ids: Vec<String>) -> Result<EnvelopeEncryptedData>;\n    \n    // Profile decryption\n    pub fn decrypt_with_profile(&self, envelope: &EnvelopeEncryptedData, profile_id: &str) -> Result<Vec<u8>>;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"node-key-manager",children:"Node Key Manager"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct NodeKeyManager {\n    // Generate node identity and CSR\n    pub fn new(logger: Arc<Logger>) -> Result<Self>;\n    pub fn generate_csr(&mut self) -> Result<SetupToken>;\n    \n    // Install certificate from mobile\n    pub fn install_certificate(&mut self, cert_message: NodeCertificateMessage) -> Result<()>;\n    \n    // Install network key from mobile\n    pub fn install_network_key(&mut self, key_message: NetworkKeyMessage) -> Result<()>;\n    \n    // Get QUIC certificate configuration\n    pub fn get_quic_certificate_config(&self) -> Result<QuicCertificateConfig>;\n    \n    // Envelope decryption\n    pub fn decrypt_envelope_data(&self, envelope: &EnvelopeEncryptedData) -> Result<Vec<u8>>;\n    \n    // Local storage encryption\n    pub fn encrypt_local_data(&self, data: &[u8]) -> Result<Vec<u8>>;\n    pub fn decrypt_local_data(&self, encrypted_data: &[u8]) -> Result<Vec<u8>>;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"serializer-registry",children:"Serializer Registry"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct SerializerRegistry {\n    // Create registry with keystore and label resolver\n    pub fn with_keystore(\n        logger: Arc<Logger>,\n        keystore: Arc<dyn KeyStore>,\n        resolver: Arc<dyn LabelResolver>,\n    ) -> Self;\n    \n    // Register encryptable types\n    pub fn register_encryptable<T: Encrypt + 'static>(&mut self) -> Result<()>;\n    \n    // Serialize with encryption\n    pub fn serialize_value(&self, value: &ArcValue) -> Result<Vec<u8>>;\n    \n    // Deserialize with decryption\n    pub fn deserialize_value(&self, data: Vec<u8>) -> Result<ArcValue>;\n    \n    // Decrypt label group\n    pub fn decrypt_label_group<T: for<'de> Deserialize<'de>>(&self, group: &EncryptedLabelGroup) -> Result<T>;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["This documentation reflects the current implementation as of the latest release. For implementation details, see the end-to-end tests in ",(0,t.jsx)(n.code,{children:"runar-keys/tests/end_to_end_test.rs"})," and ",(0,t.jsx)(n.code,{children:"runar-serializer/src/tests.rs"}),"."]})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>o});var i=r(6540);const t={},s=i.createContext(t);function l(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);
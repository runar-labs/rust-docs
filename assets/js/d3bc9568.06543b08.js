"use strict";(self.webpackChunkrunar_docs=self.webpackChunkrunar_docs||[]).push([[1529],{3215:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>t,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"features/vmap","title":"ValueMap (VMap)","description":"ValueMap (VMap) provides an ergonomic interface for working with structured data in Runar applications. It simplifies parameter extraction and creation using a set of powerful macros.","source":"@site/docs/features/vmap.md","sourceDirName":"features","slug":"/features/vmap","permalink":"/rust-docs/docs/features/vmap","draft":false,"unlisted":false,"editUrl":"https://github.com/runar-labs/runar-rust/tree/main/rust-docs/markdown/docs/features/vmap.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Logging Framework Usage Guidelines","permalink":"/rust-docs/docs/features/logging"},"next":{"title":"Runar Node System Architecture","permalink":"/rust-docs/docs/core/architecture"}}');var r=a(4848),i=a(8453);const t={},l="ValueMap (VMap)",c={},d=[{value:"Key Features",id:"key-features",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Complete Macro Reference",id:"complete-macro-reference",level:2},{value:"General-Purpose Macro",id:"general-purpose-macro",level:3},{value:"Type-Specific Extraction Macros",id:"type-specific-extraction-macros",level:3},{value:"String Values",id:"string-values",level:4},{value:"Integer Values",id:"integer-values",level:4},{value:"Floating Point Values",id:"floating-point-values",level:4},{value:"Boolean Values",id:"boolean-values",level:4},{value:"Collections",id:"collections",level:4},{value:"Date and Time (with chrono feature)",id:"date-and-time-with-chrono-feature",level:4},{value:"Nested Key Access",id:"nested-key-access",level:3},{value:"Optional Values",id:"optional-values",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Service Parameter Extraction",id:"service-parameter-extraction",level:3},{value:"Event Data Extraction",id:"event-data-extraction",level:3},{value:"Response Data Handling",id:"response-data-handling",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"valuemap-vmap",children:"ValueMap (VMap)"})}),"\n",(0,r.jsx)(n.p,{children:"ValueMap (VMap) provides an ergonomic interface for working with structured data in Runar applications. It simplifies parameter extraction and creation using a set of powerful macros."}),"\n",(0,r.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type-safe parameter extraction"})," with sensible defaults"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Specialized macros"})," for different data types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Nested key access"})," with dot notation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type inference"})," from default values"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Comprehensive error handling"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// Create a map with key-value pairs\nlet params = vmap! {\n    "name" => "user123",\n    "age" => 30,\n    "is_active" => true,\n    "tags" => ["admin", "premium"],\n    "profile" => {\n        "address" => "123 Main St",\n        "created_at" => "2023-01-15T08:30:00Z"\n    }\n};\n\n// Extract values with defaults\nlet username = vmap!(params, "name" => "guest");\nlet age = vmap!(params, "age" => 0);\nlet is_active = vmap!(params, "is_active" => false);\n\n// Nested key access with dot notation\nlet address = vmap!(params, "profile.address" => "Unknown");\n'})}),"\n",(0,r.jsx)(n.h2,{id:"complete-macro-reference",children:"Complete Macro Reference"}),"\n",(0,r.jsx)(n.h3,{id:"general-purpose-macro",children:"General-Purpose Macro"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"vmap!"})," macro has two forms:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Creating a map:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let params = vmap! {\n    "key1" => "value1",\n    "key2" => 42,\n    "key3" => true\n};\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Extracting values:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let value = vmap!(source, "key" => default_value);\n'})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"type-specific-extraction-macros",children:"Type-Specific Extraction Macros"}),"\n",(0,r.jsx)(n.p,{children:"Specialized macros provide cleaner code with type-specific default values:"}),"\n",(0,r.jsx)(n.h4,{id:"string-values",children:"String Values"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// Using general vmap! macro\nlet name = vmap!(params, "name" => String::new());\n\n// Using specialized macro - cleaner!\nlet name = vmap_str!(params, "name" => "");\n'})}),"\n",(0,r.jsx)(n.h4,{id:"integer-values",children:"Integer Values"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// Signed integers\nlet count = vmap_i32!(params, "count" => 0);\nlet small_num = vmap_i8!(params, "small_num" => 0);\nlet medium_num = vmap_i16!(params, "medium_num" => 0);\nlet large_num = vmap_i64!(params, "large_num" => 0);\n\n// Unsigned integers\nlet byte_val = vmap_u8!(params, "byte_val" => 0);\nlet positive_num = vmap_u32!(params, "positive_num" => 0);\nlet big_num = vmap_u64!(params, "big_num" => 0);\n'})}),"\n",(0,r.jsx)(n.h4,{id:"floating-point-values",children:"Floating Point Values"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let price = vmap_f64!(params, "price" => 0.0);\nlet rating = vmap_f32!(params, "rating" => 0.0);\n'})}),"\n",(0,r.jsx)(n.h4,{id:"boolean-values",children:"Boolean Values"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let is_enabled = vmap_bool!(params, "is_enabled" => false);\n'})}),"\n",(0,r.jsx)(n.h4,{id:"collections",children:"Collections"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let tags = vmap_vec!(params, "tags" => Vec::<String>::new());\n'})}),"\n",(0,r.jsx)(n.h4,{id:"date-and-time-with-chrono-feature",children:"Date and Time (with chrono feature)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let created_date = vmap_date!(params, "created_date" => \n    chrono::NaiveDate::from_ymd_opt(2000, 1, 1).unwrap());\n\nlet updated_at = vmap_datetime!(params, "updated_at" => chrono::Utc::now());\n'})}),"\n",(0,r.jsx)(n.h3,{id:"nested-key-access",children:"Nested Key Access"}),"\n",(0,r.jsx)(n.p,{children:"All macros support dot notation for accessing nested values:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// Deeply nested data\nlet params = vmap! {\n    "user" => {\n        "profile" => {\n            "contact" => {\n                "email" => "user@example.com"\n            }\n        }\n    }\n};\n\n// Access with dot notation\nlet email = vmap_str!(params, "user.profile.contact.email" => "no-email");\n'})}),"\n",(0,r.jsx)(n.h3,{id:"optional-values",children:"Optional Values"}),"\n",(0,r.jsx)(n.p,{children:"For truly optional values (not just providing defaults):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// Check if key exists first\nlet optional_value = if params.contains_key("optional_field") {\n    Some(vmap!(params, "optional_field" => String::new()))\n} else {\n    None\n};\n\n// Pattern matching on result\nmatch optional_value {\n    Some(value) => println!("Found value: {}", value),\n    None => println!("Value not provided")\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,r.jsx)(n.h3,{id:"service-parameter-extraction",children:"Service Parameter Extraction"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[action]\nasync fn handle_create_user(&self, username: String, email: String, full_name: Option<String>, age: Option<i32>, is_admin: Option<bool>, ctx: &RequestContext) -> Result<String> {\n    // Validate required fields (type system ensures non-empty)\n    if username.is_empty() || email.is_empty() {\n        anyhow::bail!("Username and email are required");\n    }\n    \n    // Use provided values or sensible defaults\n    let full_name = full_name.unwrap_or_else(|| username.clone());\n    let age = age.unwrap_or(0);\n    let is_admin = is_admin.unwrap_or(false);\n    \n    // Create user...\n    let user_id = create_user(username, email, full_name, age, is_admin).await?;\n    \n    // Return the user ID directly\n    Ok(user_id)\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"event-data-extraction",children:"Event Data Extraction"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'async fn on_user_updated(&self, payload: ArcValue) -> Result<()> {\n    // Extract event data with appropriate defaults\n    let user_id = vmap_str!(payload, "user_id" => "");\n    let old_email = vmap_str!(payload, "old_email" => "");\n    let new_email = vmap_str!(payload, "new_email" => "");\n    \n    // Process email change notification\n    if !old_email.is_empty() && !new_email.is_empty() && old_email != new_email {\n        let notification_data = vmap! {\n            "user_id" => user_id,\n            "type" => "email_changed",\n            "old_email" => old_email,\n            "new_email" => new_email\n        };\n        \n        self.notification_service.send_notification(notification_data).await?;\n    }\n    \n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"response-data-handling",children:"Response Data Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'async fn get_user_details(node: &Node, user_id: &str) -> Result<UserDetails> {\n    // Make service request - returns the User struct directly\n    let user: User = node.request("user_service/get_user", Some(ArcValue::new_primitive(user_id))).await?;\n    \n    // If you need to extract from ArcValue payloads (e.g., events), use vmap macros:\n    let payload = ArcValue::from_struct(&user);\n    let username = vmap_str!(payload, "username" => "");\n    let email = vmap_str!(payload, "email" => "");\n    \n    // But typically you\'d just use the struct fields directly\n    Ok(UserDetails {\n        user_id: user.id,\n        username: user.username,\n        email: user.email,\n        created_at: user.created_at,\n        address: user.profile.address,\n        phone: user.profile.phone\n    })\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// With error propagation\nfn get_required_param(params: &ArcValue, name: &str) -> Result<String> {\n    let value = vmap_str!(params, name => "");\n    if value.is_empty() {\n        Err(anyhow!("Missing required parameter: {}", name))\n    } else {\n        Ok(value)\n    }\n}\n\n// With pattern matching\nmatch vmap_i32!(params, "count" => -1) {\n    n if n < 0 => println!("Parameter \'count\' not found"),\n    0 => println!("Count is zero"),\n    n => println!("Count is {}", n)\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use specialized macros"})," for better readability:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"vmap_str!"}),", ",(0,r.jsx)(n.code,{children:"vmap_i32!"}),", ",(0,r.jsx)(n.code,{children:"vmap_bool!"}),", etc. instead of generic ",(0,r.jsx)(n.code,{children:"vmap!"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Provide sensible defaults"})," that match your application's logic"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use dot notation"})," for nested access instead of multiple extraction steps"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Extract and validate"})," parameters at function entry points"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use type inference"})," from defaults instead of explicit type annotations"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,r.jsx)(n.p,{children:"The VMap implementation consists of:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"VMap"})," struct wrapping a ",(0,r.jsx)(n.code,{children:"HashMap<String, ArcValue>"})]}),"\n",(0,r.jsx)(n.li,{children:"Type-specific extraction methods for different data types"}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"vmap!"})," macro with type inference for simplified access"]}),"\n",(0,r.jsx)(n.li,{children:"Specialized macros for common data types"}),"\n",(0,r.jsx)(n.li,{children:"Support for nested key access via dot notation"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Context System - Context for secure communication"}),"\n",(0,r.jsx)(n.li,{children:"Request Handling - Using VMap in request handlers"}),"\n",(0,r.jsx)(n.li,{children:"Service Lifecycle - Service lifecycle and initialization"}),"\n",(0,r.jsx)(n.li,{children:"Logging System - Context-aware, structured logging"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}}}]);
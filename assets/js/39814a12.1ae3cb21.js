"use strict";(self.webpackChunkrunar_docs=self.webpackChunkrunar_docs||[]).push([[166],{2499:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"features/enhanced-serialization","title":"Enhanced Serialization with Selective Field Encryption","description":"This document describes the enhanced serialization system in Runar that provides selective field encryption with label-based key resolution.","source":"@site/docs/features/enhanced-serialization.md","sourceDirName":"features","slug":"/features/enhanced-serialization","permalink":"/rust-docs/docs/features/enhanced-serialization","draft":false,"unlisted":false,"editUrl":"https://github.com/runar-labs/runar-rust/tree/main/rust-docs/markdown/docs/features/enhanced-serialization.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Runar Encryption Schema","permalink":"/rust-docs/docs/features/encryption-schema"},"next":{"title":"Runar Key Management System","permalink":"/rust-docs/docs/features/keys-management"}}');var s=r(4848),t=r(8453);const l={},a="Enhanced Serialization with Selective Field Encryption",o={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Selective Field Encryption",id:"selective-field-encryption",level:2},{value:"Field Annotation",id:"field-annotation",level:3},{value:"Label Semantics",id:"label-semantics",level:3},{value:"Common Label Patterns",id:"common-label-patterns",level:3},{value:"Label-Based Key Resolution",id:"label-based-key-resolution",level:2},{value:"Key Mapping Configuration",id:"key-mapping-configuration",level:3},{value:"Key Scope Types",id:"key-scope-types",level:3},{value:"Resolver Implementation",id:"resolver-implementation",level:3},{value:"Encryption Groups",id:"encryption-groups",level:2},{value:"Group Structure",id:"group-structure",level:3},{value:"Group Formation",id:"group-formation",level:3},{value:"Generated Structures",id:"generated-structures",level:3},{value:"API Reference",id:"api-reference",level:2},{value:"Serializer Registry",id:"serializer-registry",level:3},{value:"Encryption Functions",id:"encryption-functions",level:3},{value:"Traits",id:"traits",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Access Control Example",id:"access-control-example",level:3},{value:"Advanced Usage with Generated Structures",id:"advanced-usage-with-generated-structures",level:3},{value:"Integration with Key Management",id:"integration-with-key-management",level:2},{value:"Mobile Integration",id:"mobile-integration",level:3},{value:"Node Integration",id:"node-integration",level:3},{value:"Cross-Device Data Sharing",id:"cross-device-data-sharing",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Label Design",id:"label-design",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Security Considerations",id:"security-considerations",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"enhanced-serialization-with-selective-field-encryption",children:"Enhanced Serialization with Selective Field Encryption"})}),"\n",(0,s.jsx)(n.p,{children:"This document describes the enhanced serialization system in Runar that provides selective field encryption with label-based key resolution."}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#selective-field-encryption",children:"Selective Field Encryption"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#label-based-key-resolution",children:"Label-Based Key Resolution"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#encryption-groups",children:"Encryption Groups"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#api-reference",children:"API Reference"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#usage-examples",children:"Usage Examples"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#integration-with-key-management",children:"Integration with Key Management"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"runar-serializer"})," provides enhanced serialization capabilities that go beyond simple data serialization. It enables:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Selective Field Encryption"}),": Encrypt specific fields while leaving others in plaintext"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Label-Based Key Resolution"}),": Map field labels to cryptographic keys"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-Recipient Access Control"}),": Different entities can access different fields"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Envelope Encryption Integration"}),": Leverages the envelope encryption system"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type-Safe Serialization"}),": Maintains type safety throughout the encryption process"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"selective-field-encryption",children:"Selective Field Encryption"}),"\n",(0,s.jsx)(n.h3,{id:"field-annotation",children:"Field Annotation"}),"\n",(0,s.jsx)(n.p,{children:"Fields can be annotated with labels that determine their encryption behavior:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[derive(Encrypt, serde::Serialize, serde::Deserialize, Debug, PartialEq, Clone)]\npub struct TestProfile {\n    pub id: String,                    // Always in plaintext (no annotation)\n    #[runar(user, system, search)]\n    pub name: String,                  // Encrypted with user, system, and search keys\n    #[runar(user, system, search)]\n    pub email: String,                 // Encrypted with user, system, and search keys\n    #[runar(user)]\n    pub user_private: String,          // Encrypted with user key only\n    #[runar(user, system, search)]\n    pub created_at: u64,               // Encrypted with user, system, and search keys\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"label-semantics",children:"Label Semantics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No Annotation"}),": Field remains in plaintext"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Single Label"}),": Field encrypted with one key type"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multiple Labels"}),": Field encrypted with multiple key types for different access patterns"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-label-patterns",children:"Common Label Patterns"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Label"}),(0,s.jsx)(n.th,{children:"Purpose"}),(0,s.jsx)(n.th,{children:"Access Control"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"user"})}),(0,s.jsx)(n.td,{children:"User-specific data"}),(0,s.jsx)(n.td,{children:"Mobile device with profile key"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"system"})}),(0,s.jsx)(n.td,{children:"System-wide data"}),(0,s.jsx)(n.td,{children:"Nodes with network key"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"search"})}),(0,s.jsx)(n.td,{children:"Searchable data"}),(0,s.jsx)(n.td,{children:"Nodes with network key for indexing"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"admin"})}),(0,s.jsx)(n.td,{children:"Administrative data"}),(0,s.jsx)(n.td,{children:"Admin nodes only"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"public"})}),(0,s.jsx)(n.td,{children:"Public data"}),(0,s.jsx)(n.td,{children:"No encryption (for compatibility)"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"label-based-key-resolution",children:"Label-Based Key Resolution"}),"\n",(0,s.jsx)(n.h3,{id:"key-mapping-configuration",children:"Key Mapping Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Labels are resolved to cryptographic keys through a configurable resolver:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use runar_serializer::traits::{KeyScope, LabelKeyInfo};\n\nlet mobile_label_config = KeyMappingConfig {\n    label_mappings: HashMap::from([\n        (\n            "user".to_string(),\n            LabelKeyInfo {\n                public_key: profile_pk.clone(),\n                scope: KeyScope::Profile,\n            },\n        ),\n        (\n            "system".to_string(),\n            LabelKeyInfo {\n                public_key: network_pub.clone(),\n                scope: KeyScope::Network,\n            },\n        ),\n        (\n            "search".to_string(),\n            LabelKeyInfo {\n                public_key: network_pub.clone(),\n                scope: KeyScope::Network,\n            },\n        ),\n    ]),\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"key-scope-types",children:"Key Scope Types"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Profile"}),": Keys derived from user profile (mobile device)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Network"}),": Keys shared across network nodes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Node"}),": Keys specific to a single node"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"System"}),": Keys for system-wide operations"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"resolver-implementation",children:"Resolver Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub trait LabelResolver {\n    fn resolve_label(&self, label: &str) -> Result<Option<Vec<u8>>>;\n    fn resolve_label_info(&self, label: &str) -> Result<Option<LabelKeyInfo>>;\n    fn can_resolve(&self, label: &str) -> bool;\n    fn available_labels(&self) -> Vec<String>;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"encryption-groups",children:"Encryption Groups"}),"\n",(0,s.jsx)(n.h3,{id:"group-structure",children:"Group Structure"}),"\n",(0,s.jsx)(n.p,{children:"Fields with the same labels are grouped and encrypted together:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct EncryptedLabelGroup {\n    pub label: String,                    // The label this group was encrypted with\n    pub envelope: EnvelopeEncryptedData,  // Envelope-encrypted payload\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"group-formation",children:"Group Formation"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Field Analysis"}),": Analyze struct fields for label annotations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Grouping"}),": Group fields by their labels"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Serialization"}),": Serialize each group into a separate structure"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Encryption"}),": Encrypt each group using envelope encryption"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"generated-structures",children:"Generated Structures"}),"\n",(0,s.jsxs)(n.p,{children:["For the ",(0,s.jsx)(n.code,{children:"TestProfile"})," example, the following structures are generated:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Plaintext structure (no encryption)\npub struct TestProfilePlaintext {\n    pub id: String,\n}\n\n// User-encrypted structure\npub struct TestProfileUserFields {\n    pub name: String,\n    pub email: String,\n    pub user_private: String,\n    pub created_at: u64,\n}\n\n// System-encrypted structure\npub struct TestProfileSystemFields {\n    pub name: String,\n    pub email: String,\n    pub created_at: u64,\n}\n\n// Search-encrypted structure\npub struct TestProfileSearchFields {\n    pub name: String,\n    pub email: String,\n    pub created_at: u64,\n}\n\n// Encrypted structure\npub struct EncryptedTestProfile {\n    pub id: String,                           // Plaintext\n    pub user_encrypted: Option<EncryptedLabelGroup>,\n    pub system_encrypted: Option<EncryptedLabelGroup>,\n    pub search_encrypted: Option<EncryptedLabelGroup>,\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,s.jsx)(n.h3,{id:"serializer-registry",children:"Serializer Registry"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct SerializerRegistry {\n    // Create registry with keystore and label resolver\n    pub fn with_keystore(\n        logger: Arc<Logger>,\n        keystore: Arc<dyn KeyStore>,\n        resolver: Arc<dyn LabelResolver>,\n    ) -> Self;\n    \n    // Register encryptable types\n    pub fn register_encryptable<T: Encrypt + 'static>(&mut self) -> Result<()>;\n    \n    // Register plain types (no encryption)\n    pub fn register<T: 'static>(&mut self) -> Result<()>;\n    \n    // Serialize with encryption\n    pub fn serialize_value(&self, value: &ArcValue) -> Result<Vec<u8>>;\n    \n    // Deserialize with decryption\n    pub fn deserialize_value(&self, data: Vec<u8>) -> Result<ArcValue>;\n    \n    // Decrypt label group\n    pub fn decrypt_label_group<T: for<'de> Deserialize<'de>>(&self, group: &EncryptedLabelGroup) -> Result<T>;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"encryption-functions",children:"Encryption Functions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Encrypt a group of fields that share the same label\npub fn encrypt_label_group<T: Serialize>(\n    label: &str,\n    fields_struct: &T,\n    keystore: &KeyStore,\n    resolver: &dyn LabelResolver,\n) -> Result<EncryptedLabelGroup>;\n\n// Decrypt a label group back into its original struct\npub fn decrypt_label_group<T: for<'de> Deserialize<'de>>(\n    encrypted_group: &EncryptedLabelGroup,\n    keystore: &KeyStore,\n) -> Result<T>;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"traits",children:"Traits"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Mark a type as encryptable\npub trait Encrypt {\n    // This trait is automatically implemented by the derive macro\n}\n\n// Key store interface\npub trait KeyStore {\n    fn encrypt_with_envelope(\n        &self,\n        data: &[u8],\n        network_id: &str,\n        profile_ids: Vec<String>,\n    ) -> Result<EnvelopeEncryptedData>;\n    \n    fn decrypt_envelope_data(&self, envelope: &EnvelopeEncryptedData) -> Result<Vec<u8>>;\n}\n\n// Label resolver interface\npub trait LabelResolver {\n    fn resolve_label(&self, label: &str) -> Result<Option<Vec<u8>>>;\n    fn resolve_label_info(&self, label: &str) -> Result<Option<LabelKeyInfo>>;\n    fn can_resolve(&self, label: &str) -> bool;\n    fn available_labels(&self) -> Vec<String>;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,s.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use runar_serializer::*;\nuse runar_common::types::ArcValue;\n\n// Define an encryptable struct\n#[derive(Encrypt, serde::Serialize, serde::Deserialize, Debug, PartialEq, Clone)]\npub struct UserProfile {\n    pub id: String,\n    #[runar(user, system)]\n    pub name: String,\n    #[runar(user)]\n    pub private_notes: String,\n    #[runar(system)]\n    pub public_info: String,\n}\n\n// Create serializer registry\nlet mut registry = SerializerRegistry::with_keystore(\n    logger.clone(),\n    keystore.clone(),\n    Arc::new(resolver),\n);\n\n// Register the type\nregistry.register_encryptable::<UserProfile>()?;\n\n// Create data\nlet profile = UserProfile {\n    id: "user123".to_string(),\n    name: "Alice".to_string(),\n    private_notes: "Secret notes".to_string(),\n    public_info: "Public information".to_string(),\n};\n\n// Serialize with encryption\nlet arc_value = ArcValue::from_struct(profile.clone());\nlet serialized = registry.serialize_value(&arc_value)?;\n\n// Deserialize with decryption\nlet deserialized = registry.deserialize_value(serialized)?;\nlet roundtrip_profile = deserialized.as_struct_ref::<UserProfile>()?;\nassert_eq!(&*roundtrip_profile, &profile);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"access-control-example",children:"Access Control Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Mobile side - can decrypt user and system fields\nlet mobile_registry = SerializerRegistry::with_keystore(\n    logger.clone(),\n    mobile_keystore.clone(),\n    Arc::new(mobile_resolver),\n);\n\nlet mobile_profile = mobile_registry.deserialize_value(serialized.clone())?;\nlet mobile_data = mobile_profile.as_struct_ref::<UserProfile>()?;\nassert_eq!(mobile_data.name, "Alice");           // \u2705 Can decrypt\nassert_eq!(mobile_data.private_notes, "Secret notes"); // \u2705 Can decrypt\nassert_eq!(mobile_data.public_info, "Public information"); // \u2705 Can decrypt\n\n// Node side - can only decrypt system fields\nlet node_registry = SerializerRegistry::with_keystore(\n    logger.clone(),\n    node_keystore.clone(),\n    Arc::new(node_resolver),\n);\n\nlet node_profile = node_registry.deserialize_value(serialized)?;\nlet node_data = node_profile.as_struct_ref::<UserProfile>()?;\nassert_eq!(node_data.name, "Alice");             // \u2705 Can decrypt (system label)\nassert_eq!(node_data.private_notes, "");         // \u274c Cannot decrypt (user only)\nassert_eq!(node_data.public_info, "Public information"); // \u2705 Can decrypt\n'})}),"\n",(0,s.jsx)(n.h3,{id:"advanced-usage-with-generated-structures",children:"Advanced Usage with Generated Structures"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Access the encrypted structure directly\nlet encrypted_profile = deserialized.as_struct_ref::<EncryptedUserProfile>()?;\n\n// Check which groups are available\nif let Some(user_group) = &encrypted_profile.user_encrypted {\n    // Decrypt user-specific fields\n    let user_fields: UserProfileUserFields = registry.decrypt_label_group(user_group)?;\n    println!("User fields: {:?}", user_fields);\n}\n\nif let Some(system_group) = &encrypted_profile.system_encrypted {\n    // Decrypt system fields\n    let system_fields: UserProfileSystemFields = registry.decrypt_label_group(system_group)?;\n    println!("System fields: {:?}", system_fields);\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"integration-with-key-management",children:"Integration with Key Management"}),"\n",(0,s.jsx)(n.h3,{id:"mobile-integration",children:"Mobile Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use runar_keys::mobile::MobileKeyManager;\n\n// Create mobile key manager\nlet mut mobile = MobileKeyManager::new(logger)?;\nmobile.initialize_user_root_key()?;\n\n// Derive profile key\nlet profile_pk = mobile.derive_user_profile_key("user")?;\n\n// Create label resolver\nlet mobile_resolver = ConfigurableLabelResolver::new(KeyMappingConfig {\n    label_mappings: HashMap::from([\n        ("user".to_string(), LabelKeyInfo {\n            public_key: profile_pk,\n            scope: KeyScope::Profile,\n        }),\n    ]),\n});\n\n// Create serializer registry\nlet registry = SerializerRegistry::with_keystore(\n    logger,\n    Arc::new(mobile),\n    Arc::new(mobile_resolver),\n);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"node-integration",children:"Node Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use runar_keys::node::NodeKeyManager;\n\n// Create node key manager\nlet mut node = NodeKeyManager::new(logger)?;\n\n// Install network key from mobile\nnode.install_network_key(network_key_message)?;\n\n// Create label resolver\nlet node_resolver = ConfigurableLabelResolver::new(KeyMappingConfig {\n    label_mappings: HashMap::from([\n        ("system".to_string(), LabelKeyInfo {\n            public_key: network_pub,\n            scope: KeyScope::Network,\n        }),\n    ]),\n});\n\n// Create serializer registry\nlet registry = SerializerRegistry::with_keystore(\n    logger,\n    Arc::new(node),\n    Arc::new(node_resolver),\n);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"cross-device-data-sharing",children:"Cross-Device Data Sharing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Mobile encrypts data for sharing\nlet profile = UserProfile { /* ... */ };\nlet arc_value = ArcValue::from_struct(profile);\nlet serialized = mobile_registry.serialize_value(&arc_value)?;\n\n// Node can decrypt system fields\nlet node_profile = node_registry.deserialize_value(serialized)?;\nlet node_data = node_profile.as_struct_ref::<UserProfile>()?;\n\n// Mobile can decrypt all fields\nlet mobile_profile = mobile_registry.deserialize_value(serialized)?;\nlet mobile_data = mobile_profile.as_struct_ref::<UserProfile>()?;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"label-design",children:"Label Design"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Semantic Labels"}),": Choose labels that reflect the data's purpose"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Minimize Labels"}),": Use the fewest labels necessary for access control"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consistent Naming"}),": Use consistent label names across your application"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Document Labels"}),": Document what each label means and who can access it"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Group Similar Fields"}),": Fields with the same labels are encrypted together"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Avoid Over-Encryption"}),": Don't encrypt fields that don't need protection"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cache Resolvers"}),": Reuse label resolvers when possible"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Batch Operations"}),": Process multiple objects together when possible"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Key Management"}),": Ensure keys are properly managed and rotated"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Access Control"}),": Verify that label resolvers provide appropriate access"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Audit Trail"}),": Log encryption/decryption operations for security auditing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Key Separation"}),": Use different keys for different purposes"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["This documentation reflects the current implementation as of the latest release. For implementation details, see the tests in ",(0,s.jsx)(n.code,{children:"runar-serializer/src/tests.rs"}),"."]})})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>a});var i=r(6540);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);
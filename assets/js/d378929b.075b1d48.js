"use strict";(self.webpackChunkrunar_docs=self.webpackChunkrunar_docs||[]).push([[4169],{4550:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"core/architecture","title":"Runar Node System Architecture","description":"This document describes the high-level architecture of the Runar node system, including core components, data flow patterns, design principles, and implementation guidelines.","source":"@site/docs/core/architecture.md","sourceDirName":"core","slug":"/core/architecture","permalink":"/rust-docs/docs/core/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/runar-labs/runar-rust/tree/main/rust-docs/markdown/docs/core/architecture.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"ValueMap (VMap)","permalink":"/rust-docs/docs/features/vmap"},"next":{"title":"Discovery Mechanism Specification","permalink":"/rust-docs/docs/core/discovery"}}');var s=t(4848),r=t(8453);const a={},c="Runar Node System Architecture",l={},o=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Core Components",id:"core-components",level:2},{value:"Node",id:"node",level:3},{value:"Service Registry",id:"service-registry",level:3},{value:"Abstract Service",id:"abstract-service",level:3},{value:"Request Context",id:"request-context",level:3},{value:"Logging System",id:"logging-system",level:3},{value:"Database System",id:"database-system",level:3},{value:"IPC System",id:"ipc-system",level:3},{value:"Data Flow Patterns",id:"data-flow-patterns",level:2},{value:"Request/Response Pattern",id:"requestresponse-pattern",level:3},{value:"Publish/Subscribe Pattern",id:"publishsubscribe-pattern",level:3},{value:"Design Principles",id:"design-principles",level:2},{value:"Service Organization",id:"service-organization",level:3},{value:"Communication Patterns",id:"communication-patterns",level:3},{value:"Request/Response",id:"requestresponse",level:4},{value:"Publish/Subscribe",id:"publishsubscribe",level:4},{value:"Subscription Processing",id:"subscription-processing",level:5},{value:"Subscription Propagation",id:"subscription-propagation",level:5},{value:"Event Handler Lifecycle Management",id:"event-handler-lifecycle-management",level:3},{value:"Implementation Guidelines",id:"implementation-guidelines",level:3},{value:"Service Implementation Patterns",id:"service-implementation-patterns",level:3},{value:"Service Lifecycle Management",id:"service-lifecycle-management",level:2},{value:"Service Initialization",id:"service-initialization",level:3},{value:"P2P Architecture",id:"p2p-architecture",level:2},{value:"Service Discovery",id:"service-discovery",level:3},{value:"Peer-to-Peer Communication",id:"peer-to-peer-communication",level:3},{value:"Network Configuration",id:"network-configuration",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Authentication",id:"authentication",level:3},{value:"Authorization",id:"authorization",level:3},{value:"Secure Communication",id:"secure-communication",level:3},{value:"End-to-End Examples",id:"end-to-end-examples",level:2},{value:"Complete Application Example",id:"complete-application-example",level:3},{value:"Proper Architectural Patterns",id:"proper-architectural-patterns",level:3},{value:"Service Communication Flow",id:"service-communication-flow",level:3},{value:"Example Implementations",id:"example-implementations",level:2},{value:"TaskService Implementation",id:"taskservice-implementation",level:3},{value:"TaskMonitorService Implementation",id:"taskmonitorservice-implementation",level:3},{value:"Usage Example",id:"usage-example",level:3},{value:"Key Architecture Features",id:"key-architecture-features",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"runar-node-system-architecture",children:"Runar Node System Architecture"})}),"\n",(0,s.jsx)(n.p,{children:"This document describes the high-level architecture of the Runar node system, including core components, data flow patterns, design principles, and implementation guidelines."}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#core-components",children:"Core Components"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#node",children:"Node"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#service-registry",children:"Service Registry"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#abstract-service",children:"Abstract Service"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#request-context",children:"Request Context"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#logging-system",children:"Logging System"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#database-system",children:"Database System"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#ipc-system",children:"IPC System"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#data-flow-patterns",children:"Data Flow Patterns"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#requestresponse-pattern",children:"Request/Response Pattern"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#publishsubscribe-pattern",children:"Publish/Subscribe Pattern"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#design-principles",children:"Design Principles"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#service-organization",children:"Service Organization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#communication-patterns",children:"Communication Patterns"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#event-handler-lifecycle-management",children:"Event Handler Lifecycle"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#implementation-guidelines",children:"Implementation Guidelines"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#service-implementation-patterns",children:"Service Implementation Patterns"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#service-lifecycle-management",children:"Service Lifecycle Management"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#service-initialization",children:"Service Initialization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#subscription-management",children:"Subscription Management"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#p2p-architecture",children:"P2P Architecture"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#service-discovery",children:"Service Discovery"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#peer-to-peer-communication",children:"Peer-to-Peer Communication"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#network-configuration",children:"Network Configuration"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#security-considerations",children:"Security Considerations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#authentication",children:"Authentication"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#authorization",children:"Authorization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#secure-communication",children:"Secure Communication"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#end-to-end-examples",children:"End-to-End Examples"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#complete-application-example",children:"Complete Application Example"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#proper-architectural-patterns",children:"Proper Architectural Patterns"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#service-communication-flow",children:"Service Communication Flow"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"This document provides an overview of the key components and principles governing the system design."}),"\n",(0,s.jsx)(n.h2,{id:"core-components",children:"Core Components"}),"\n",(0,s.jsx)(n.h3,{id:"node",children:"Node"}),"\n",(0,s.jsx)(n.p,{children:"The central component that manages services and provides core functionality:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Defined in ",(0,s.jsx)(n.code,{children:"node.rs"})]}),"\n",(0,s.jsx)(n.li,{children:"Contains configuration, service management, and network operations"}),"\n",(0,s.jsx)(n.li,{children:"Acts as the main entry point for the application"}),"\n",(0,s.jsx)(n.li,{children:"Provides interfaces for service communication and event handling"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"service-registry",children:"Service Registry"}),"\n",(0,s.jsx)(n.p,{children:"Manages service registration, discovery, and communication:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Defined in ",(0,s.jsx)(n.code,{children:"services/registry.rs"})]}),"\n",(0,s.jsx)(n.li,{children:"Maintains a map of registered services"}),"\n",(0,s.jsx)(n.li,{children:"Routes requests to appropriate services"}),"\n",(0,s.jsx)(n.li,{children:"Handles publish/subscribe for events"}),"\n",(0,s.jsx)(n.li,{children:"Manages remote service discovery and communication"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"abstract-service",children:"Abstract Service"}),"\n",(0,s.jsx)(n.p,{children:"Base trait implemented by all services:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Defined in ",(0,s.jsx)(n.code,{children:"services/abstract_service.rs"})]}),"\n",(0,s.jsx)(n.li,{children:"Provides unified lifecycle management (init, start, stop)"}),"\n",(0,s.jsx)(n.li,{children:"Standardizes request processing"}),"\n",(0,s.jsx)(n.li,{children:"Defines service state transitions"}),"\n",(0,s.jsxs)(n.li,{children:["Provides service metadata through methods:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name()"}),": Returns the service name"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"path()"}),": Returns the service path"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"description()"}),": Returns a description of the service"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"version()"}),": Returns the service version"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"request-context",children:"Request Context"}),"\n",(0,s.jsx)(n.p,{children:"Context for service requests:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Handles path routing and parameter passing"}),"\n",(0,s.jsx)(n.li,{children:"Provides a uniform interface for service communication"}),"\n",(0,s.jsx)(n.li,{children:"Enables service-to-service communication"}),"\n",(0,s.jsx)(n.li,{children:"Manages event subscription and publishing"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"logging-system",children:"Logging System"}),"\n",(0,s.jsx)(n.p,{children:"Component-based logging for debugging and monitoring:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Defined in ",(0,s.jsx)(n.code,{children:"util/logging.rs"})]}),"\n",(0,s.jsx)(n.li,{children:"Categorizes logs by system component"}),"\n",(0,s.jsx)(n.li,{children:"Supports multiple log levels"}),"\n",(0,s.jsx)(n.li,{children:"Provides structured logging capabilities"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"database-system",children:"Database System"}),"\n",(0,s.jsx)(n.p,{children:"SQLite-based storage layer:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Defined in ",(0,s.jsx)(n.code,{children:"db.rs"})," and ",(0,s.jsx)(n.code,{children:"services/sqlite.rs"})]}),"\n",(0,s.jsx)(n.li,{children:"Provides persistence for system data"}),"\n",(0,s.jsx)(n.li,{children:"Supports CRUD operations and queries"}),"\n",(0,s.jsx)(n.li,{children:"Manages database connections and transactions"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"ipc-system",children:"IPC System"}),"\n",(0,s.jsx)(n.p,{children:"Client-server communication:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Facilitates communication with external processes"}),"\n",(0,s.jsx)(n.li,{children:"Implements secure inter-process communication"}),"\n",(0,s.jsx)(n.li,{children:"Provides APIs for external service integration"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"data-flow-patterns",children:"Data Flow Patterns"}),"\n",(0,s.jsx)(n.p,{children:"The Runar node system follows two primary data flow patterns:"}),"\n",(0,s.jsx)(n.h3,{id:"requestresponse-pattern",children:"Request/Response Pattern"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Client Request"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Requests begin in the ",(0,s.jsx)(n.code,{children:"RequestContext"})," with a path and parameters"]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"NodeRequestHandlerImpl"})," parses the path into service name and operation"]}),"\n",(0,s.jsx)(n.li,{children:"Requests are routed to appropriate services through the registry"}),"\n",(0,s.jsx)(n.li,{children:"Services process requests and return responses"}),"\n",(0,s.jsx)(n.li,{children:"Responses flow back through the handler to the client"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Request Routing Flow"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Client \u2192 Node \u2192 ServiceRegistry \u2192 TargetService \u2192 process_request() \u2192 Response\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"publishsubscribe-pattern",children:"Publish/Subscribe Pattern"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Event Publication"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Publishers emit events to specific topics"}),"\n",(0,s.jsx)(n.li,{children:"The service registry manages topic subscriptions"}),"\n",(0,s.jsx)(n.li,{children:"Subscribers receive events when published to their topics"}),"\n",(0,s.jsx)(n.li,{children:"Events include metadata like timestamps"}),"\n",(0,s.jsx)(n.li,{children:"Subscribers process events based on topic and content"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Event Flow"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Publisher \u2192 Node \u2192 ServiceRegistry \u2192 Topic Subscribers \u2192 Event Handlers\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"design-principles",children:"Design Principles"}),"\n",(0,s.jsx)(n.h3,{id:"service-organization",children:"Service Organization"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Each functionality should be implemented as a dedicated service"}),"\n",(0,s.jsx)(n.li,{children:"Services should be self-contained and follow the single responsibility principle"}),"\n",(0,s.jsx)(n.li,{children:"Avoid conditional routing within services - use dedicated services for different functionalities"}),"\n",(0,s.jsxs)(n.li,{children:["Information services should be separate from their data sources (e.g., ",(0,s.jsx)(n.code,{children:"RegistryInfoService"})," separate from ",(0,s.jsx)(n.code,{children:"ServiceRegistry"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"Use delegation pattern when a service needs to expose data from another component"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"communication-patterns",children:"Communication Patterns"}),"\n",(0,s.jsx)(n.h4,{id:"requestresponse",children:"Request/Response"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["All service requests must include a ",(0,s.jsx)(n.code,{children:"RequestContext"})]}),"\n",(0,s.jsx)(n.li,{children:'Path format should be "serviceName/operation" to enable proper routing'}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"NodeRequestHandler"})," should parse the path to extract service name and operation"]}),"\n",(0,s.jsx)(n.li,{children:"Services should process requests based on the operation field"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"publishsubscribe",children:"Publish/Subscribe"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Publish operations should mirror request pattern (same path parsing, context handling)"}),"\n",(0,s.jsx)(n.li,{children:"No response is expected from publish operations"}),"\n",(0,s.jsx)(n.li,{children:"Event handlers should receive the same context as request handlers"}),"\n",(0,s.jsx)(n.li,{children:"Context allows event handlers to make additional service calls or trigger events"}),"\n",(0,s.jsx)(n.li,{children:'Subscribe operations should use the complete path (e.g., "user/created")'}),"\n",(0,s.jsx)(n.li,{children:"Service name should be extracted from path using the same mechanism as requests"}),"\n",(0,s.jsx)(n.li,{children:"Each topic should have a clear ownership model (which service owns which topics)"}),"\n"]}),"\n",(0,s.jsx)(n.h5,{id:"subscription-processing",children:"Subscription Processing"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When subscribing from within a service, the service name is implied and can be omitted"}),"\n",(0,s.jsx)(n.li,{children:"When subscribing directly from a Node without a service context, an anonymous service is created"}),"\n",(0,s.jsx)(n.li,{children:"Anonymous subscribers are registered in the ServiceRegistry with a unique service name"}),"\n",(0,s.jsx)(n.li,{children:"This ensures all subscribers are tied to a service, maintaining a consistent architecture"}),"\n",(0,s.jsx)(n.li,{children:"Anonymous services are implemented as fully-functional AbstractService instances"}),"\n"]}),"\n",(0,s.jsx)(n.h5,{id:"subscription-propagation",children:"Subscription Propagation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When a node subscribes to a topic, the subscription should be stored in the local registry"}),"\n",(0,s.jsx)(n.li,{children:'All non-internal services (events and actions) (topics not starting with "internal/") should be propagated to all connected peers'}),"\n",(0,s.jsx)(n.li,{children:"Internal topics are meant for local node usage only and should not be shared across the network"}),"\n",(0,s.jsx)(n.li,{children:"This ensures that peers are aware of what topics each node is interested in"}),"\n",(0,s.jsx)(n.li,{children:"Propagating subscriptions allows nodes to route events across the network efficiently"}),"\n",(0,s.jsx)(n.li,{children:"When a node receives a remote subscription, it should record it for future event routing"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"event-handler-lifecycle-management",children:"Event Handler Lifecycle Management"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Event handlers remain active until explicitly unregistered using:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"node.unsubscribe(topic, [handler_id])"})," at the Node level"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"context.unsubscribe(topic, [handler_id])"})," from within a RequestContext"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["One-time event handlers that auto-unregister after being triggered once:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"node.once(topic, callback)"})," at the Node level"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"context.once(topic, callback)"})," from within a RequestContext"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Advanced subscription options via ",(0,s.jsx)(n.code,{children:"subscribe_with_options()"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Supports TTL (time-to-live) for automatic cleanup after a specified duration"}),"\n",(0,s.jsx)(n.li,{children:"Supports max_triggers to automatically unregister after being triggered N times"}),"\n",(0,s.jsx)(n.li,{children:"Supports conditional unsubscribe based on callback return value"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Anonymous services for subscriptions are subject to the following lifecycle:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Created when a subscription is registered without a service context"}),"\n",(0,s.jsx)(n.li,{children:"Remain active as long as they have at least one active subscription"}),"\n",(0,s.jsx)(n.li,{children:"Can be manually unregistered or expire based on subscription options"}),"\n",(0,s.jsx)(n.li,{children:"Periodic cleanup removes services with no active subscriptions"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation-guidelines",children:"Implementation Guidelines"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Maintain consistent path handling across all communication patterns"}),"\n",(0,s.jsx)(n.li,{children:"Make service boundaries explicit and well-defined"}),"\n",(0,s.jsx)(n.li,{children:"Services should expose clear interfaces through their operations"}),"\n",(0,s.jsx)(n.li,{children:"Prefer composition over inheritance when extending functionality"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"service-implementation-patterns",children:"Service Implementation Patterns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Service Operation Delegation:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"process_request"})," method should match on the operation name and delegate to local methods"]}),"\n",(0,s.jsx)(n.li,{children:"Local method names should match the operation names for clarity and traceability"}),"\n",(0,s.jsxs)(n.li,{children:["Example: ",(0,s.jsx)(n.code,{children:'operation "get_data"'})," should call a local method named ",(0,s.jsx)(n.code,{children:"get_data()"})]}),"\n",(0,s.jsx)(n.li,{children:"This improves code organization, readability, and testability"}),"\n",(0,s.jsxs)(n.li,{children:["Complex operation implementations should be moved out of the ",(0,s.jsx)(n.code,{children:"process_request"})," method"]}),"\n",(0,s.jsx)(n.li,{children:"Each operation should have a single, focused implementation method"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"service-lifecycle-management",children:"Service Lifecycle Management"}),"\n",(0,s.jsx)(n.p,{children:"The following diagram illustrates the lifecycle of a service in the Runar node system:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:"sequenceDiagram\n    participant N as Node\n    participant SR as ServiceRegistry\n    participant S as Service\n    participant ES as EventSystem\n\n    N->>S: Create Service\n    Note over S: State: Created\n    N->>S: Initialize Service\n    S->>ES: Register Subscriptions\n    Note over S: State: Initialized\n    N->>S: Start Service\n    Note over S: State: Running\n    S->>SR: Register Service\n    \n    Note over S: Service Processing...\n    \n    N->>S: Stop Service\n    S->>ES: Unregister Subscriptions\n    S->>SR: Unregister Service\n    Note over S: State: Stopped\n"})}),"\n",(0,s.jsx)(n.h3,{id:"service-initialization",children:"Service Initialization"}),"\n",(0,s.jsx)(n.p,{children:"The following diagram illustrates the service initialization flow:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:"flowchart TD\n    A[Create Service] --\x3e B[Call init Method]\n    B --\x3e C[Setup Resources]\n    C --\x3e D[Register Subscriptions]\n    D --\x3e E[Set State to Initialized]\n    E --\x3e F[Call start Method]\n    F --\x3e G[Register with Service Registry]\n    G --\x3e H[Set State to Running]\n    H --\x3e I[Begin Processing Requests]\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Subscription Setup:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Service subscriptions should be established during the initialization phase (",(0,s.jsx)(n.code,{children:"init"})," method)"]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"init"})," method MUST receive a RequestContext parameter to enable subscription registration"]}),"\n",(0,s.jsxs)(n.li,{children:["Subscriptions should NEVER be set up in the ",(0,s.jsx)(n.code,{children:"process_request"})," method"]}),"\n",(0,s.jsxs)(n.li,{children:["Reasons for this pattern:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Ensures subscriptions are set up exactly once when the service starts"}),"\n",(0,s.jsx)(n.li,{children:"Prevents redundant subscription setup on every request"}),"\n",(0,s.jsx)(n.li,{children:"Maintains clear separation of concerns in the service lifecycle"}),"\n",(0,s.jsx)(n.li,{children:"Improves performance by avoiding unnecessary subscription checks"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"If a service needs to verify subscriptions are active, use a private method that checks state rather than attempting to re-subscribe"}),"\n",(0,s.jsx)(n.li,{children:"For dynamic subscriptions that depend on runtime parameters, create dedicated operations for subscription management"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Service Initialization Flow:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Services should have a predictable initialization flow: create \u2192 init \u2192 start"}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"init"})," method is where all one-time setup like subscriptions should occur"]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"start"})," method should focus on activating the service's functionality"]}),"\n",(0,s.jsxs)(n.li,{children:["Subscriptions registered during ",(0,s.jsx)(n.code,{children:"init"})," should follow the service's lifecycle"]}),"\n",(0,s.jsx)(n.li,{children:"When a service is stopped, its subscriptions should be unregistered"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"p2p-architecture",children:"P2P Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"service-discovery",children:"Service Discovery"}),"\n",(0,s.jsx)(n.p,{children:"The Runar node system implements a comprehensive service discovery mechanism across the P2P network:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Service Advertisement"}),": Services are automatically advertised to connected peers when registered"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Remote Service Discovery"}),": Services are discovered when connecting to peers in the P2P network"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Service Lookup"}),": The Node provides a ",(0,s.jsx)(n.code,{children:"wait_for_service"})," method to wait for service availability"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Service Availability"}),": Services can be local or remote, with transparent access through the service registry"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Timeout Support"}),": Service discovery includes timeout mechanisms to prevent indefinite waiting"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Wait for a service to become available with a 5-second timeout\nlet service_available = node.wait_for_service("remote_service", Some(5000)).await;\nif service_available {\n    // Service is ready to use\n} else {\n    // Handle service unavailable\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"peer-to-peer-communication",children:"Peer-to-Peer Communication"}),"\n",(0,s.jsx)(n.p,{children:"The P2P layer in Runar nodes implements the following features:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transport Protocol"}),": QUIC-based transport for reliable, secure, and multiplexed communication"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Peer Identification"}),": Peers are identified by a PeerId derived from their public key"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Network Participation"}),": Peers can participate in multiple networks with network-specific keys"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Access Control"}),": Network access is controlled through cryptographic AccessTokens"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Message Routing"}),": Messages are routed to appropriate services across the P2P network"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Discovery Mechanism"}),": Peers discover each other using UDP multicast and DHT routing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"NAT Traversal"}),": STUN-like server and UDP hole punching for connectivity across NATs"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"network-configuration",children:"Network Configuration"}),"\n",(0,s.jsx)(n.p,{children:"P2P functionality in Runar nodes is configured through the Node configuration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Example P2P configuration\nlet p2p_config = TransportConfig {\n    network_id: "network_id".to_string(),\n    state_path: "state_path".to_string(),\n    bootstrap_nodes: Some(vec!["127.0.0.1:50601".to_string()]),\n    listen_addr: Some("127.0.0.1:50602".to_string()),\n};\n\n// Create and initialize node with P2P support\nlet mut node = Node::new(NodeConfig {\n    node_id: "my_node".to_string(),\n    data_dir: "./data".to_string(),\n    db_path: "./data/db".to_string(),\n    p2p_config: Some(p2p_config),\n}).await?;\n'})}),"\n",(0,s.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"authentication",children:"Authentication"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Services should authenticate requests when necessary"}),"\n",(0,s.jsx)(n.li,{children:"P2P connections require mutual authentication through AccessTokens"}),"\n",(0,s.jsx)(n.li,{children:"Authentication should be performed at the service boundary"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"authorization",children:"Authorization"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Services should implement appropriate authorization checks"}),"\n",(0,s.jsx)(n.li,{children:"Access to sensitive operations should be restricted"}),"\n",(0,s.jsx)(n.li,{children:"Access control should be enforced consistently across all services"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"secure-communication",children:"Secure Communication"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"All P2P communication uses QUIC with TLS for encryption"}),"\n",(0,s.jsx)(n.li,{children:"Service-to-service communication within a node is memory-safe"}),"\n",(0,s.jsx)(n.li,{children:"External communication channels should be properly secured"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"end-to-end-examples",children:"End-to-End Examples"}),"\n",(0,s.jsx)(n.p,{children:"This section provides complete examples showcasing how the architectural patterns work together in real applications."}),"\n",(0,s.jsx)(n.h3,{id:"complete-application-example",children:"Complete Application Example"}),"\n",(0,s.jsx)(n.p,{children:"Below is a complete example demonstrating proper service implementation, registration, and interaction:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use runar_macros::{action, service, subscribe};\nuse runar_node::{\n    anyhow::{self, Result},\n    async_trait::async_trait,\n    node::NodeConfig,\n    Node, ValueType, vmap,\n};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n// Define data types\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct Task {\n    id: String,\n    title: String,\n    completed: bool,\n}\n\n// Define the task service\n#[service(name = "task_service")]\nstruct TaskService {\n    tasks: Arc<RwLock<HashMap<String, Task>>>,\n}\n\n// Constructor and methods\nimpl TaskService {\n    fn new() -> Self {\n        Self {\n            tasks: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n    \n    // Action handler for creating a task\n    #[action(name = "create_task")]\n    async fn create_task(&self, context: &RequestContext, title: String) -> Result<Task> {\n        let id = uuid::Uuid::new_v4().to_string();\n        let task = Task {\n            id: id.clone(),\n            title,\n            completed: false,\n        };\n        \n        // Store the task\n        let mut tasks = self.tasks.write().await;\n        tasks.insert(id.clone(), task.clone());\n        \n        // Publish event about task creation\n        let event_data = vmap! {\n            "task_id" => task.id.clone(),\n            "title" => task.title.clone()\n        };\n        context.publish("tasks/created", event_data).await?;\n        \n        Ok(task)\n    }\n    \n    // Action handler for completing a task\n    #[action(name = "complete_task")]\n    async fn complete_task(&self, context: &RequestContext, id: String) -> Result<Task> {\n        let mut tasks = self.tasks.write().await;\n        let task = tasks.get_mut(&id)\n            .ok_or_else(|| anyhow::anyhow!("Task not found"))?;\n            \n        task.completed = true;\n        \n        // Publish event about task completion\n        let event_data = vmap! {\n            "task_id" => task.id.clone()\n        };\n        context.publish("tasks/completed", event_data).await?;\n        \n        Ok(task.clone())\n    }\n    \n    // Action handler for listing tasks\n    #[action(name = "list_tasks")]\n    async fn list_tasks(&self) -> Result<Vec<Task>> {\n        let tasks = self.tasks.read().await;\n        Ok(tasks.values().cloned().collect())\n    }\n}\n\n// Define an analytics service\n#[service(name = "analytics_service")]\nstruct AnalyticsService {\n    task_counts: Arc<RwLock<HashMap<String, u32>>>,\n}\n\nimpl AnalyticsService {\n    fn new() -> Self {\n        Self {\n            task_counts: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n    \n    // Subscribe to task creation events\n    #[subscribe(topic = "tasks/created")]\n    async fn on_task_created(&mut self, payload: ValueType) -> Result<()> {\n        let task_id = vmap_str!(payload, "task_id" => "");\n        let title = vmap_str!(payload, "title" => "");\n        \n        println!("Analytics: New task created: {} - {}", task_id, title);\n        \n        // Update statistics\n        let mut counts = self.task_counts.write().await;\n        *counts.entry("created".to_string()).or_insert(0) += 1;\n        \n        Ok(())\n    }\n    \n    // Subscribe to task completion events\n    #[subscribe(topic = "tasks/completed")]\n    async fn on_task_completed(&mut self, payload: ValueType) -> Result<()> {\n        let task_id = vmap_str!(payload, "task_id" => "");\n        \n        println!("Analytics: Task completed: {}", task_id);\n        \n        // Update statistics\n        let mut counts = self.task_counts.write().await;\n        *counts.entry("completed".to_string()).or_insert(0) += 1;\n        \n        Ok(())\n    }\n    \n    // Action handler for getting task statistics\n    #[action(name = "get_stats")]\n    async fn get_stats(&self) -> Result<HashMap<String, u32>> {\n        let counts = self.task_counts.read().await;\n        Ok(counts.clone())\n    }\n}\n\n// Main application\n#[tokio::main]\nasync fn main() -> Result<()> {\n    // 1. Create node with configuration\n    let config = NodeConfig::default()\n        .with_name("task_manager")\n        .with_description("Task Management Application");\n        \n    let mut node = Node::new(config).await?;\n    \n    // 2. Initialize node\n    node.init().await?;\n    \n    // 3. Create services\n    let task_service = TaskService::new();\n    let analytics_service = AnalyticsService::new();\n    \n    // 4. Register services with the node using the proper add_service method\n    node.add_service(task_service).await?;\n    node.add_service(analytics_service).await?;\n    \n    // 5. Start the node to activate all services\n    node.start().await?;\n    \n    // 6. Use services through the request-based API\n    \n    // Create a new task\n    let create_params = vmap! {\n        "title" => "Learn Runar Architecture"\n    };\n    let create_result = node.request("task_service/create_task", create_params).await?;\n    \n    // Extract task ID using vmap! for clean extraction with defaults\n    let task_id = vmap_str!(create_result.data, "id" => "");\n    println!("Created task with ID: {}", task_id);\n    \n    // Complete the task\n    let complete_params = vmap! {\n        "id" => task_id\n    };\n    let complete_result = node.request("task_service/complete_task", complete_params).await?;\n    println!("Task completed: {:?}", complete_result);\n    \n    // List all tasks\n    let list_result = node.request("task_service/list_tasks", ValueType::Null).await?;\n    println!("All tasks: {:?}", list_result);\n    \n    // Get analytics stats\n    let stats_result = node.request("analytics_service/get_stats", ValueType::Null).await?;\n    println!("Task statistics: {:?}", stats_result);\n    \n    // 7. Clean shutdown\n    node.stop().await?;\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"proper-architectural-patterns",children:"Proper Architectural Patterns"}),"\n",(0,s.jsx)(n.p,{children:"This example demonstrates all the critical architectural patterns:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Service Definition"}),": Services are defined with clear responsibilities (TaskService, AnalyticsService)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Service Registration"}),": Using ",(0,s.jsx)(n.code,{children:"node.add_service()"})," to properly register services"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Request-based API"}),": Using ",(0,s.jsx)(n.code,{children:"node.request()"})," for all service interactions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event-driven Communication"}),": Services communicate via events for loose coupling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clean Parameter Extraction"}),": Using specialized vmap macros (",(0,s.jsx)(n.code,{children:"vmap_str!"}),", ",(0,s.jsx)(n.code,{children:"vmap_i32!"}),", etc.) for safe extraction with defaults"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Proper Lifecycle Management"}),": Following create \u2192 init \u2192 start \u2192 use \u2192 stop"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"service-communication-flow",children:"Service Communication Flow"}),"\n",(0,s.jsx)(n.p,{children:"The sequence diagram below illustrates the complete communication flow in our example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:'sequenceDiagram\n    participant Client\n    participant Node\n    participant TaskService\n    participant AnalyticsService\n    \n    Client->>Node: Create Node\n    Node->>TaskService: Initialize\n    Node->>AnalyticsService: Initialize\n    AnalyticsService->>Node: Subscribe to "tasks/created"\n    AnalyticsService->>Node: Subscribe to "tasks/completed"\n    Client->>Node: Start Node\n    Client->>Node: request("task_service/create_task", params)\n    Node->>TaskService: route request to create_task\n    TaskService->>Node: publish("tasks/created", data)\n    Node->>AnalyticsService: Notify about created task\n    AnalyticsService->>AnalyticsService: Update stats\n    TaskService->>Node: Return created task\n    Node->>Client: Return response\n    \n    Client->>Node: request("task_service/complete_task", params)\n    Node->>TaskService: route request to complete_task\n    TaskService->>Node: publish("tasks/completed", data)\n    Node->>AnalyticsService: Notify about completed task\n    AnalyticsService->>AnalyticsService: Update stats\n    TaskService->>Node: Return updated task\n    Node->>Client: Return response\n    \n    Client->>Node: request("analytics_service/get_stats", null)\n    Node->>AnalyticsService: route request to get_stats\n    AnalyticsService->>Node: Return statistics\n    Node->>Client: Return response\n    \n    Client->>Node: Stop Node\n    Node->>TaskService: Stop\n    Node->>AnalyticsService: Stop\n'})}),"\n",(0,s.jsx)(n.p,{children:"This comprehensive example demonstrates how all the architectural elements work together in a cohesive application, following the recommended patterns and guidelines."}),"\n",(0,s.jsx)(n.h2,{id:"example-implementations",children:"Example Implementations"}),"\n",(0,s.jsx)(n.h3,{id:"taskservice-implementation",children:"TaskService Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use anyhow::Result;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse runar_node::{\n    Node, ValueType, vmap,\n    services::{\n        AbstractService, RequestContext, ResponseStatus, \n        ServiceRequest, ServiceResponse, ServiceState\n    }\n};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\nuse uuid::Uuid;\n\nstruct Task {\n    id: String,\n    title: String,\n    description: String,\n    completed: bool,\n    created_at: String,\n    updated_at: String,\n}\n\nimpl Task {\n    fn new(title: &str, description: &str) -> Self {\n        let now = Utc::now().to_rfc3339();\n        Self {\n            id: Uuid::new_v4().to_string(),\n            title: title.to_string(),\n            description: description.to_string(),\n            completed: false,\n            created_at: now.clone(),\n            updated_at: now,\n        }\n    }\n    \n    fn mark_complete(&mut self) {\n        self.completed = true;\n        self.updated_at = Utc::now().to_rfc3339();\n    }\n    \n    fn to_value_type(&self) -> ValueType {\n        let event_data = vmap! {\n            "id" => self.id.clone(),\n            "title" => self.title.clone(),\n            "description" => self.description.clone(),\n            "completed" => self.completed,\n            "created_at" => self.created_at.clone(),\n            "updated_at" => self.updated_at.clone()\n        };\n        event_data\n    }\n}\n\nstruct TaskService {\n    name: String,\n    path: String,\n    state: ServiceState,\n    tasks: Arc<Mutex<HashMap<String, Task>>>,\n}\n\nimpl TaskService {\n    fn new(name: &str) -> Self {\n        Self {\n            name: name.to_string(),\n            path: name.to_string(),\n            state: ServiceState::Created,\n            tasks: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n    \n    async fn handle_create(&self, request: &ServiceRequest, context: &RequestContext) -> Result<ServiceResponse> {\n        // Extract parameters using vmap! with proper defaults\n        let title = vmap_str!(request.params, "title" => "");\n        let description = vmap_str!(request.params, "description" => "");\n        \n        // Create a new task\n        let task = Task::new(&title, &description);\n        let task_id = task.id.clone();\n        \n        // Store the task\n        {\n            let mut tasks = self.tasks.lock().await;\n            tasks.insert(task_id.clone(), task.clone());\n        }\n        \n        // Publish task created event\n        let event_data = vmap! {\n            "task_id" => task_id.clone(),\n            "title" => title\n        };\n        \n        context.publish(&format!("{}/task_created", self.path), event_data).await?;\n        \n        // Return the task ID\n        Ok(ServiceResponse {\n            status: ResponseStatus::Success,\n            message: "Task created successfully".to_string(),\n            data: Some(vmap! {\n                "id" => task_id\n            }),\n        })\n    }\n    \n    async fn handle_complete(&self, request: &ServiceRequest, context: &RequestContext) -> Result<ServiceResponse> {\n        // Extract task ID using vmap! with default value\n        let task_id = vmap_str!(request.params, "task_id" => "");\n        \n        let mut task_found = false;\n        \n        // Mark the task as complete\n        {\n            let mut tasks = self.tasks.lock().await;\n            if let Some(task) = tasks.get_mut(&task_id) {\n                task.mark_complete();\n                task_found = true;\n            }\n        }\n        \n        if task_found {\n            // Publish task completed event\n            let event_data = vmap! {\n                "task_id" => task_id\n            };\n            \n            context.publish(&format!("{}/task_completed", self.path), event_data).await?;\n            \n            // Return success response\n            Ok(ServiceResponse {\n                status: ResponseStatus::Success,\n                message: "Task marked as complete".to_string(),\n                data: None,\n            })\n        } else {\n            // Return error response\n            Ok(ServiceResponse {\n                status: ResponseStatus::Error,\n                message: format!("Task with ID {} not found", task_id),\n                data: None,\n            })\n        }\n    }\n}\n\n#[async_trait]\nimpl AbstractService for TaskService {\n    fn name(&self) -> &str {\n        &self.name\n    }\n    \n    fn path(&self) -> &str {\n        &self.path\n    }\n    \n    fn state(&self) -> ServiceState {\n        self.state\n    }\n    \n    fn description(&self) -> &str {\n        "Service for managing tasks"\n    }\n    \n    fn version(&self) -> &str {\n        "1.0.0"\n    }\n    \n    async fn init(&mut self, _context: &RequestContext) -> Result<()> {\n        self.state = ServiceState::Initialized;\n        Ok(())\n    }\n    \n    async fn start(&mut self) -> Result<()> {\n        self.state = ServiceState::Running;\n        Ok(())\n    }\n    \n    async fn stop(&mut self) -> Result<()> {\n        self.state = ServiceState::Stopped;\n        Ok(())\n    }\n    \n    async fn handle_request(&self, request: ServiceRequest) -> Result<ServiceResponse> {\n        match request.operation.as_str() {\n            "create" => self.handle_create(&request, &request.request_context).await,\n            "complete" => self.handle_complete(&request, &request.request_context).await,\n            _ => Ok(ServiceResponse {\n                status: ResponseStatus::Error,\n                message: format!("Unknown operation: {}", request.operation),\n                data: None,\n            }),\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"taskmonitorservice-implementation",children:"TaskMonitorService Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'struct TaskMonitorService {\n    name: String,\n    path: String,\n    state: ServiceState,\n    task_counts: Arc<Mutex<HashMap<String, usize>>>,\n}\n\nimpl TaskMonitorService {\n    fn new(name: &str) -> Self {\n        let mut counts = HashMap::new();\n        counts.insert("created".to_string(), 0);\n        counts.insert("completed".to_string(), 0);\n        \n        Self {\n            name: name.to_string(),\n            path: name.to_string(),\n            state: ServiceState::Created,\n            task_counts: Arc::new(Mutex::new(counts)),\n        }\n    }\n    \n    async fn on_task_created(&self, payload: ValueType) -> Result<()> {\n        // Extract task ID using vmap! with default value\n        let task_id = vmap_str!(payload, "task_id" => "");\n        let title = vmap_str!(payload, "title" => "");\n        \n        // Update counts\n        {\n            let mut counts = self.task_counts.lock().await;\n            *counts.entry("created".to_string()).or_insert(0) += 1;\n        }\n        \n        println!("TaskMonitorService: New task created - ID: {}, Title: {}", task_id, title);\n        Ok(())\n    }\n    \n    async fn on_task_completed(&self, payload: ValueType) -> Result<()> {\n        // Extract task ID using vmap! with default value\n        let task_id = vmap_str!(payload, "task_id" => "");\n        \n        // Update counts\n        {\n            let mut counts = self.task_counts.lock().await;\n            *counts.entry("completed".to_string()).or_insert(0) += 1;\n        }\n        \n        println!("TaskMonitorService: Task completed - ID: {}", task_id);\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl AbstractService for TaskMonitorService {\n    // ... other trait methods as shown above ...\n    \n    async fn init(&mut self, context: &RequestContext) -> Result<()> {\n        // Subscribe to task events\n        context.subscribe("task_service/task_created", move |payload| {\n            let this = self.clone();\n            Box::pin(async move {\n                this.on_task_created(payload).await\n            })\n        }).await?;\n        \n        context.subscribe("task_service/task_completed", move |payload| {\n            let this = self.clone();\n            Box::pin(async move {\n                this.on_task_completed(payload).await\n            })\n        }).await?;\n        \n        self.state = ServiceState::Initialized;\n        Ok(())\n    }\n    \n    // ... other trait methods as shown above ...\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"usage-example",children:"Usage Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[tokio::main]\nasync fn main() -> Result<()> {\n    // Create a node\n    let mut node = Node::new(/* config */);\n    \n    // Add services\n    let task_service = TaskService::new("task_service");\n    let monitor_service = TaskMonitorService::new("task_monitor");\n    \n    node.add_service(task_service).await?;\n    node.add_service(monitor_service).await?;\n    \n    // Start the node\n    node.start().await?;\n    \n    // Create a task\n    let create_params = vmap! {\n        "title" => "Implement architecture",\n        "description" => "Create a clean, modular architecture"\n    };\n    \n    let create_result = node.request("task_service/create", create_params).await?;\n    \n    // Extract task ID using vmap! for clean extraction with defaults\n    let task_id = vmap_str!(create_result.data, "id" => "");\n    \n    // Complete the task\n    let complete_params = vmap! {\n        "task_id" => task_id\n    };\n    \n    node.request("task_service/complete", complete_params).await?;\n    \n    // Node shutdown will happen automatically when it goes out of scope\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"key-architecture-features",children:"Key Architecture Features"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Service Boundaries"}),": Tasks and monitoring are separate services"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event-Driven Communication"}),": Services communicate via events"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Request-Response Pattern"}),": Task operations use request-response"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clean Module Organization"}),": Each component has a clear responsibility"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clean Parameter Extraction"}),": Using specialized vmap macros (",(0,s.jsx)(n.code,{children:"vmap_str!"}),", ",(0,s.jsx)(n.code,{children:"vmap_i32!"}),", etc.) for safe extraction with defaults"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);
"use strict";(self.webpackChunkrunar_docs=self.webpackChunkrunar_docs||[]).push([[969],{1398:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"core/discovery","title":"Discovery Mechanism Specification","description":"This specification defines the discovery mechanism for the P2P network, allowing peers to locate each other on the same local network using UDP multicast. It includes secure validation of discovery messages to ensure only authorized peers are considered for connection.","source":"@site/docs/core/discovery.md","sourceDirName":"core","slug":"/core/discovery","permalink":"/docs/core/discovery","draft":false,"unlisted":false,"editUrl":"https://github.com/runar-labs/runar-rust/tree/main/rust-docs/markdown/docs/core/discovery.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Runar Node System Architecture","permalink":"/docs/core/architecture"},"next":{"title":"Logging System","permalink":"/docs/core/logging"}}');var r=s(4848),c=s(8453);const o={},t="Discovery Mechanism Specification",d={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Discovery Method",id:"discovery-method",level:2},{value:"Multicast Group",id:"multicast-group",level:2},{value:"Discovery Message",id:"discovery-message",level:2},{value:"AccessToken in Discovery",id:"accesstoken-in-discovery",level:2},{value:"Sending Discovery Messages",id:"sending-discovery-messages",level:2},{value:"Receiving Discovery Messages",id:"receiving-discovery-messages",level:2},{value:"Security",id:"security",level:2},{value:"References Between Specifications",id:"references-between-specifications",level:2},{value:"P2P Transport Layer",id:"p2p-transport-layer",level:3},{value:"Keys Management",id:"keys-management",level:3},{value:"Discovery Mechanism",id:"discovery-mechanism",level:3},{value:"Implementation Example",id:"implementation-example",level:2},{value:"Examples",id:"examples",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"discovery-mechanism-specification",children:"Discovery Mechanism Specification"})}),"\n",(0,r.jsx)(n.p,{children:"This specification defines the discovery mechanism for the P2P network, allowing peers to locate each other on the same local network using UDP multicast. It includes secure validation of discovery messages to ensure only authorized peers are considered for connection."}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#discovery-method",children:"Discovery Method"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#multicast-group",children:"Multicast Group"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#discovery-message",children:"Discovery Message"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#accesstoken-in-discovery",children:"AccessToken in Discovery"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#sending-discovery-messages",children:"Sending Discovery Messages"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#receiving-discovery-messages",children:"Receiving Discovery Messages"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#security",children:"Security"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#references-between-specifications",children:"References Between Specifications"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(n.p,{children:"This specification defines the discovery mechanism for the P2P network, allowing peers to locate each other on the same local network using UDP multicast. It includes secure validation of discovery messages to ensure only authorized peers are considered for connection."}),"\n",(0,r.jsx)(n.p,{children:"The following diagram illustrates the P2P discovery and connection process:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mermaid",children:"sequenceDiagram\n    participant P1 as Peer1\n    participant M as Multicast Network\n    participant D as DHT Network\n    participant P2 as Peer2\n\n    P1->>M: Send Discovery Message\n    M--\x3e>P2: Receive Discovery Message\n    P2->>P1: Establish Direct Connection\n    Note over P1,P2: Connection Established\n    \n    P1->>D: Register Peer Info\n    P2->>D: Lookup Remote Peer\n    D--\x3e>P2: Return Peer Connection Info\n    P2->>P1: Establish Connection via DHT\n"})}),"\n",(0,r.jsx)(n.p,{children:"The following flow diagram illustrates the complete discovery process:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mermaid",children:"flowchart TD\n    A[Node Starts] --\x3e B[Initialize Discovery]\n    B --\x3e C[Join Multicast Group]\n    C --\x3e D[Send Discovery Message]\n    D --\x3e E[Listen for Discovery Messages]\n    \n    F[Discovery Message Received] --\x3e G[Validate Message]\n    G --\x3e H{Valid Message?}\n    H --\x3e|No| I[Discard Message]\n    H --\x3e|Yes| J[Extract Peer Info]\n    J --\x3e K[Verify Access Token]\n    K --\x3e L{Token Valid?}\n    L --\x3e|No| M[Reject Connection]\n    L --\x3e|Yes| N[Add to Peer List]\n    N --\x3e O[Establish Connection]\n    \n    P[DHT Discovery] --\x3e Q[Register in DHT]\n    Q --\x3e R[Lookup Remote Peers]\n    R --\x3e S[Connect to Remote Peers]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"discovery-method",children:"Discovery Method"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"UDP Multicast"}),": Peers periodically announce their presence and listen for announcements within the local network."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"multicast-group",children:"Multicast Group"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Address"}),": 239.255.255.250"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Port"}),": 4445"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"discovery-message",children:"Discovery Message"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Format"}),": JSON"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Structure"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "peer_id": "base64_peer_id",\n  "networks": [\n    {\n      "network_id": "base64_network_id",\n      "token": "base64_access_token"\n    }\n  ],\n  "ip": "peer_ip_address",\n  "port": "peer_tcp_port",\n  "timestamp": "unix_timestamp",\n  "version": "protocol_version"\n}\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Fields"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"peer_id"}),": Base64-encoded SHA-256 hash of the peer's Ed25519 public key (see Keys Management Specification)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"networks"}),": A list of network entries, each with:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"network_id"}),": Base64-encoded derived public key (see Keys Management Specification)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"token"}),": Base64-encoded AccessToken (see Keys Management Specification)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ip"}),", ",(0,r.jsx)(n.code,{children:"port"}),": The peer's IP address and TCP port for QUIC connections (used by P2P Transport Layer Specification)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"timestamp"}),": Unix timestamp for message freshness"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"version"}),': Protocol version (e.g., "1.0")']}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"accesstoken-in-discovery",children:"AccessToken in Discovery"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Structure"}),": Matches the AccessToken defined in the Keys Management Specification."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Validation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Receiving peers verify each token using the corresponding ",(0,r.jsx)(n.code,{children:"network_id"})," (public key)"]}),"\n",(0,r.jsxs)(n.li,{children:["Ensure the ",(0,r.jsx)(n.code,{children:"peer_id"})," in the token matches the message's ",(0,r.jsx)(n.code,{children:"peer_id"})," and the token hasn't expired"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"sending-discovery-messages",children:"Sending Discovery Messages"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Frequency"}),": Sent every 10 seconds, with \xb12 seconds of random jitter to avoid collisions."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Process"}),": Serialize the message to JSON and transmit it via UDP to the multicast group."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"receiving-discovery-messages",children:"Receiving Discovery Messages"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Processing"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Ignore messages from the peer itself (based on ",(0,r.jsx)(n.code,{children:"peer_id"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Check for common ",(0,r.jsx)(n.code,{children:"network_ids"})," with the local peer's networks"]}),"\n",(0,r.jsxs)(n.li,{children:["Verify the AccessToken for each matching network using the ",(0,r.jsx)(n.code,{children:"network_id"})]}),"\n",(0,r.jsxs)(n.li,{children:["If valid, add or update the peer in the local peer list with its ",(0,r.jsx)(n.code,{children:"ip"})," and ",(0,r.jsx)(n.code,{children:"port"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Timeout"}),": Remove peers from the list if no message is received for 30 seconds."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"security",children:"Security"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validation"}),": Ensures only peers with valid AccessTokens are considered for connection."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Timestamp"}),": Prevents replay attacks by rejecting old messages."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"references-between-specifications",children:"References Between Specifications"}),"\n",(0,r.jsx)(n.h3,{id:"p2p-transport-layer",children:"P2P Transport Layer"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Uses PeerId, NetworkId, and AccessToken from the Keys Management Specification for identity and access control."}),"\n",(0,r.jsx)(n.li,{children:"Relies on the Discovery Mechanism Specification to obtain peer addresses for QUIC connections."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"keys-management",children:"Keys Management"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Provides cryptographic identities and tokens used by both the P2P Transport Layer Specification and Discovery Mechanism Specification."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"discovery-mechanism",children:"Discovery Mechanism"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Uses AccessToken from the Keys Management Specification to secure discovery messages."}),"\n",(0,r.jsxs)(n.li,{children:["Supplies peer addresses (",(0,r.jsx)(n.code,{children:"ip"})," and ",(0,r.jsx)(n.code,{children:"port"}),") to the P2P Transport Layer Specification for establishing QUIC connections."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"implementation-example",children:"Implementation Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use runar_node::discovery::prelude::*;\nuse runar_node::keys::AccessToken;\nuse std::time::{Duration, SystemTime, UNIX_EPOCH};\n\n// Set up discovery service\nlet mut discovery = DiscoveryService::new()?;\ndiscovery\n    .set_multicast_addr("239.255.255.250:4445")\n    .set_announce_interval(Duration::from_secs(10))\n    .set_peer_timeout(Duration::from_secs(30));\n\n// Add a network to announce\nlet network_id = "base64_encoded_network_id";\nlet token = AccessToken::new(\n    peer_id, \n    network_id, \n    SystemTime::now() + Duration::from_secs(3600)\n);\ndiscovery.add_network(network_id, token);\n\n// Start the discovery service (runs in background)\ndiscovery.start()?;\n\n// Get discovered peers\nlet peers = discovery.get_peers_for_network(network_id);\nfor peer in peers {\n    println!("Discovered peer: {}:{} with ID {}", \n        peer.ip, \n        peer.port, \n        peer.peer_id\n    );\n}\n\n// Stop discovery when done\ndiscovery.stop()?;\n'})}),"\n",(0,r.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(n.p,{children:"This section will be expanded with practical examples."})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>t});var i=s(6540);const r={},c=i.createContext(r);function o(e){const n=i.useContext(c);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(c.Provider,{value:n},e.children)}}}]);
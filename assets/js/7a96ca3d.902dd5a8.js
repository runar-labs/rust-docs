"use strict";(self.webpackChunkrunar_docs=self.webpackChunkrunar_docs||[]).push([[3271],{2776:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"getting-started/overview","title":"Runar Overview","description":"Introduction","source":"@site/docs/getting-started/overview.md","sourceDirName":"getting-started","slug":"/getting-started/overview","permalink":"/rust-docs/docs/getting-started/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/runar-labs/runar-rust/tree/main/rust-docs/markdown/docs/getting-started/overview.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Runar Quick Start Guide","permalink":"/rust-docs/docs/getting-started/quickstart"},"next":{"title":"Installing Runar","permalink":"/rust-docs/docs/getting-started/installation"}}');var i=t(4848),s=t(8453),a=t(5395);const c={},o="Runar Overview",l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Core Components",id:"core-components",level:2},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Service Model",id:"service-model",level:2},{value:"Next Steps",id:"next-steps",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"runar-overview",children:"Runar Overview"})}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"Runar is a powerful distributed system framework built in Rust. It provides a declarative, approach to defining services, actions, and event subscriptions for building resilient peer-to-peer or distributed microservices applications."}),"\n",(0,i.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Distributed Architecture"}),": Fully distributed with no central points of failure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"End-to-End Encryption"}),": Secure communication between nodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Declarative API"}),": Easy-to-use macros for defining services and handlers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Event-Based Communication"}),": Publish-subscribe pattern for system events"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fault Tolerance"}),": Resilient to network failures and node crashes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Extensible"}),": Easy to add new services and functionality"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"core-components",children:"Core Components"}),"\n",(0,i.jsx)(n.p,{children:"Runar consists of several core components:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Node"}),": The main runtime that hosts services and manages communication"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Services"}),": Independent modules that provide specific functionality"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Actions"}),": Request handlers that process incoming service requests"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Events"}),": Asynchronous messages for inter-service communication"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Discovery"}),": Mechanism for finding other nodes in the network"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"P2P Layer"}),": Peer-to-peer communication layer"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,i.jsx)(n.p,{children:"The following diagram illustrates the high-level architecture of a Runar node:"}),"\n",(0,i.jsx)(a.A,{chart:"\nflowchart TD\n  Client[Client Applications] --\x3e Router\n  Router[Action Router] --\x3e S1[Service 1]\n  Router --\x3e S2[Service 2]\n  Router --\x3e S3[Service 3]\n  S1 <--\x3e EventBus[Event Bus]\n  S2 <--\x3e EventBus\n  S3 <--\x3e EventBus\n  EventBus <--\x3e P2P[P2P Layer]\n  P2P <--\x3e Network[Network]\n"}),"\n",(0,i.jsx)(n.h2,{id:"service-model",children:"Service Model"}),"\n",(0,i.jsx)(n.p,{children:"Services in Runar are defined using a declarative approach with macros:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use anyhow::Result;\nuse runar_macros::{action, service, subscribe};\nuse runar_node::services::{RequestContext, EventContext};\nuse runar_common::types::ArcValue; // Assuming ArcValue might be used\n\n#[service(name = "example_service", path = "example")]\nstruct ExampleService {\n    // Service state can be initialized in new()\n}\n\n#[service_impl]\nimpl ExampleService {\n    // Constructor following the pattern\n    pub fn new() -> Self {\n        // Initialize service state here\n        Self { }\n    }\n\n    #[action(name = "perform_task")]\n    async fn perform_task(&self, ctx: &RequestContext, input: String) -> Result<String> {\n        // Handler implementation\n        // Example: Log input and return a response\n        ctx.info(format!("perform_task called with input: {}", input));\n        Ok(format!("Task completed with input: {}", input))\n    }\n    \n    #[subscribe(topic = "event/type")]\n    async fn handle_event(&self, ctx: &EventContext, data: Option<ArcValue>) -> Result<()> {\n        // Event handler implementation\n        // Example: Log event data\n        if let Some(event_data) = data {\n            ctx.info(format!("handle_event received data: {:?}", event_data));\n        } else {\n            ctx.info("handle_event received no data".to_string());\n        }\n        Ok(())\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"installation",children:"Installation Guide"})," - Install Runar and its dependencies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"quickstart",children:"Quick Start Guide"})," - Build your first Runar application"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../core/architecture",children:"Architecture"})," - Detailed architecture documentation"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},5395:(e,n,t)=>{t.d(n,{A:()=>a});var r=t(6540),i=t(2279),s=t(4848);function a({chart:e}){const n=(0,r.useRef)(null);return(0,r.useEffect)(()=>{if(n.current){i.A.initialize({startOnLoad:!0,theme:"neutral"});const t="mermaid-"+Math.random().toString(36).substr(2,9);i.A.render(t,e).then(({svg:e})=>{n.current&&(n.current.innerHTML=e)})}},[e]),(0,s.jsx)("div",{ref:n,className:"mermaid"})}}}]);
"use strict";(self.webpackChunkrunar_docs=self.webpackChunkrunar_docs||[]).push([[557],{5388:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"core/p2p","title":"P2P Transport Layer Specification","description":"This specification defines a peer-to-peer (P2P) transport layer implemented in Rust, designed as an event bus using QUIC as the transport protocol. It supports network-specific participation, decentralized storage via a Kademlia Distributed Hash Table (DHT), and secure access control through cryptographic tokens.","source":"@site/docs/core/p2p.md","sourceDirName":"core","slug":"/core/p2p","permalink":"/rust-docs/docs/core/p2p","draft":false,"unlisted":false,"editUrl":"https://github.com/runar-labs/runar-rust/tree/main/rust-docs/markdown/docs/core/p2p.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Logging System","permalink":"/rust-docs/docs/core/logging"},"next":{"title":"Runar Node System Diagrams","permalink":"/rust-docs/docs/core/system-diagrams"}}');var s=r(4848),t=r(8453);const a={},o="P2P Transport Layer Specification",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Core Components",id:"core-components",level:2},{value:"Transport Layer",id:"transport-layer",level:3},{value:"DHT System",id:"dht-system",level:3},{value:"Network Management",id:"network-management",level:3},{value:"API Design",id:"api-design",level:2},{value:"Message Operations",id:"message-operations",level:3},{value:"Network Operations",id:"network-operations",level:3},{value:"DHT Operations",id:"dht-operations",level:3},{value:"Security",id:"security",level:2},{value:"Access Control",id:"access-control",level:3},{value:"Connection Security",id:"connection-security",level:3},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Transport Implementation",id:"transport-implementation",level:3},{value:"DHT Implementation",id:"dht-implementation",level:3},{value:"Integration",id:"integration",level:2},{value:"Service Integration",id:"service-integration",level:3},{value:"Discovery Integration",id:"discovery-integration",level:3},{value:"Examples",id:"examples",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"p2p-transport-layer-specification",children:"P2P Transport Layer Specification"})}),"\n",(0,s.jsx)(n.p,{children:"This specification defines a peer-to-peer (P2P) transport layer implemented in Rust, designed as an event bus using QUIC as the transport protocol. It supports network-specific participation, decentralized storage via a Kademlia Distributed Hash Table (DHT), and secure access control through cryptographic tokens."}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#core-components",children:"Core Components"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#transport-layer",children:"Transport Layer"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#dht-system",children:"DHT System"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#network-management",children:"Network Management"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#api-design",children:"API Design"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#message-operations",children:"Message Operations"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#network-operations",children:"Network Operations"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#dht-operations",children:"DHT Operations"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#security",children:"Security"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#access-control",children:"Access Control"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#connection-security",children:"Connection Security"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#implementation-details",children:"Implementation Details"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#transport-implementation",children:"Transport Implementation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#dht-implementation",children:"DHT Implementation"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#integration",children:"Integration"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"#service-integration",children:"Service Integration"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"#discovery-integration",children:"Discovery Integration"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"The P2P transport layer provides:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"QUIC-based reliable transport"}),"\n",(0,s.jsx)(n.li,{children:"Network-scoped DHT for decentralized storage"}),"\n",(0,s.jsx)(n.li,{children:"Secure peer authentication and authorization"}),"\n",(0,s.jsx)(n.li,{children:"Integration with the Runar node service architecture"}),"\n",(0,s.jsx)(n.li,{children:"Event-based message routing and delivery"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"core-components",children:"Core Components"}),"\n",(0,s.jsx)(n.h3,{id:"transport-layer",children:"Transport Layer"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Requirements"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reliable message delivery using QUIC"}),"\n",(0,s.jsx)(n.li,{children:"Support for Rust object serialization"}),"\n",(0,s.jsx)(n.li,{children:"Peer-to-peer and broadcast messaging"}),"\n",(0,s.jsx)(n.li,{children:"Connection multiplexing"}),"\n",(0,s.jsx)(n.li,{children:"Flow control and backpressure"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Features"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Asynchronous message handling"}),"\n",(0,s.jsx)(n.li,{children:"Automatic reconnection"}),"\n",(0,s.jsx)(n.li,{children:"Connection pooling"}),"\n",(0,s.jsx)(n.li,{children:"Quality of service options"}),"\n",(0,s.jsx)(n.li,{children:"Error recovery"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The following diagram illustrates the P2P message routing flow:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:"flowchart TD\n    A[Message Created] --\x3e B[Serialize Message]\n    B --\x3e C{Local or Remote?}\n    C --\x3e|Local| D[Process Locally]\n    C --\x3e|Remote| E[Lookup Peer Route]\n    E --\x3e F{Direct Connection?}\n    F --\x3e|Yes| G[Send via Direct Connection]\n    F --\x3e|No| H[Find Route via DHT]\n    H --\x3e I[Forward to Next Hop]\n    I --\x3e J[Receive at Destination]\n    J --\x3e K[Deserialize Message]\n    K --\x3e L[Process Message]\n    L --\x3e M[Generate Response]\n    M --\x3e N[Return via Same Route]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dht-system",children:"DHT System"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Features"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Kademlia-based routing"}),"\n",(0,s.jsx)(n.li,{children:"Network-scoped key-value storage"}),"\n",(0,s.jsx)(n.li,{children:"Replication and redundancy"}),"\n",(0,s.jsx)(n.li,{children:"Automatic peer discovery"}),"\n",(0,s.jsx)(n.li,{children:"Value expiration and refresh"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"network-management",children:"Network Management"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Features"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Network-specific participation"}),"\n",(0,s.jsx)(n.li,{children:"Access token validation"}),"\n",(0,s.jsx)(n.li,{children:"Peer authentication"}),"\n",(0,s.jsx)(n.li,{children:"Connection management"}),"\n",(0,s.jsx)(n.li,{children:"Network metadata"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"api-design",children:"API Design"}),"\n",(0,s.jsx)(n.h3,{id:"message-operations",children:"Message Operations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"/// Send a message to a specific peer\nasync fn send_to_peer<T: Serialize>(\n    &self,\n    peer_id: PeerId,\n    message: T\n) -> Result<(), Error>;\n\n/// Broadcast a message to multiple peers\nasync fn broadcast<T: Serialize>(\n    &self,\n    peer_ids: &[PeerId],\n    message: T\n) -> Result<(), Error>;\n\n/// Start listening for incoming messages\nfn start_listening(&self) -> mpsc::Receiver<(PeerId, Vec<u8>)>;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"network-operations",children:"Network Operations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"/// Configure network metadata\nasync fn set_network_metadata(\n    &self,\n    network_id: NetworkId,\n    admin_pubkey: PublicKey,\n    name: String\n) -> Result<(), Error>;\n\n/// Add network access token\nasync fn add_network_token(\n    &self,\n    network_id: NetworkId,\n    token: AccessToken\n) -> Result<(), Error>;\n\n/// Connect to a peer in a specific network\nasync fn connect_to_peer(\n    &self,\n    peer_id: PeerId,\n    network_id: NetworkId,\n    address: String\n) -> Result<Connection, Error>;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dht-operations",children:"DHT Operations"}),"\n",(0,s.jsx)(n.p,{children:"The following diagram illustrates the DHT operations in the P2P network:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:"sequenceDiagram\n    participant N1 as Node1\n    participant K1 as Kademlia (Node1)\n    participant K2 as Kademlia (Node2)\n    participant N2 as Node2\n    participant K3 as Kademlia (Node3)\n    participant N3 as Node3\n\n    N1->>K1: Store Value (Key, Value)\n    K1->>K2: Forward to Closer Node\n    K2->>N2: Store Value\n    Note over N2: Value Stored\n\n    N3->>K3: Get Value (Key)\n    K3->>K2: Query Closer Node\n    K2->>N2: Retrieve Value\n    N2--\x3e>K2: Return Value\n    K2--\x3e>K3: Forward Value\n    K3--\x3e>N3: Return Value\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"/// Store a value in the DHT\nasync fn dht_put(\n    &self,\n    network_id: NetworkId,\n    key: Vec<u8>,\n    value: Vec<u8>\n) -> Result<(), Error>;\n\n/// Retrieve a value from the DHT\nasync fn dht_get(\n    &self,\n    network_id: NetworkId,\n    key: Vec<u8>\n) -> Result<Option<Vec<u8>>, Error>;\n\n/// Bootstrap the DHT using a known peer\nasync fn bootstrap(\n    &self,\n    network_id: NetworkId,\n    bootstrap_peer: PeerId\n) -> Result<(), Error>;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"security",children:"Security"}),"\n",(0,s.jsx)(n.p,{children:"The following diagram illustrates the network authentication process:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:"sequenceDiagram\n    participant C as Client Node\n    participant A as Auth Service\n    participant N as Network Admin\n    participant T as Target Node\n\n    C->>N: Request Network Access\n    N->>A: Generate Access Token\n    A--\x3e>N: Signed Access Token\n    N--\x3e>C: Provide Access Token\n    \n    C->>T: Connect with Access Token\n    T->>T: Validate Token\n    Note over T: Check Signature\n    Note over T: Verify Permissions\n    T--\x3e>C: Connection Established/Rejected\n"})}),"\n",(0,s.jsx)(n.p,{children:"The following flow diagram illustrates the security flow in the P2P network:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:"flowchart TD\n    A[Connection Request] --\x3e B[TLS Handshake]\n    B --\x3e C[Verify Certificate]\n    C --\x3e D{Certificate Valid?}\n    D --\x3e|No| E[Reject Connection]\n    D --\x3e|Yes| F[Extract Peer ID]\n    F --\x3e G[Verify Network Access]\n    G --\x3e H{Access Token?}\n    H --\x3e|No| I[Request Access Token]\n    H --\x3e|Yes| J[Validate Token]\n    J --\x3e K{Token Valid?}\n    K --\x3e|No| L[Reject Connection]\n    K --\x3e|Yes| M[Establish Secure Channel]\n    M --\x3e N[Apply Message Encryption]\n    N --\x3e O[Connection Established]\n    \n    P[Message Received] --\x3e Q[Decrypt Message]\n    Q --\x3e R[Verify Message Integrity]\n    R --\x3e S{Integrity Check?}\n    S --\x3e|Fail| T[Discard Message]\n    S --\x3e|Pass| U[Process Message]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"access-control",children:"Access Control"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Token Validation"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"impl P2PTransport {\n    async fn validate_peer_token(\n        &self,\n        peer_id: &PeerId,\n        network_id: &NetworkId,\n        token: &AccessToken\n    ) -> Result<bool, Error> {\n        // Verify token signature using network's public key\n        if !token.verify(network_id)? {\n            return Ok(false);\n        }\n        \n        // Check token belongs to the peer\n        if token.peer_id != *peer_id {\n            return Ok(false);\n        }\n        \n        // Check expiration\n        if token.is_expired() {\n            return Ok(false);\n        }\n        \n        Ok(true)\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"connection-security",children:"Connection Security"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"QUIC Configuration"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'impl P2PTransport {\n    fn configure_quic(&self) -> QuicConfig {\n        QuicConfig::new()\n            .with_max_idle_timeout(Duration::from_secs(30))\n            .with_max_concurrent_bidi_streams(100u32)\n            .with_max_concurrent_uni_streams(100u32)\n            .with_application_protocols(vec!["runar-p2p-1".into()])\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,s.jsx)(n.h3,{id:"transport-implementation",children:"Transport Implementation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Connection Management"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct P2PTransport {\n    endpoint: QuicEndpoint,\n    connections: Arc<RwLock<HashMap<PeerId, Connection>>>,\n    networks: Arc<RwLock<HashMap<NetworkId, NetworkState>>>,\n    message_tx: mpsc::Sender<(PeerId, Vec<u8>)>,\n    message_rx: mpsc::Receiver<(PeerId, Vec<u8>)>,\n}\n\nimpl P2PTransport {\n    async fn handle_connection(&self, conn: Connection) {\n        while let Ok(stream) = conn.accept_bi().await {\n            let (mut send, mut recv) = stream;\n            \n            // Handle incoming messages\n            while let Some(message) = recv.next().await {\n                self.process_message(message).await?;\n            }\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dht-implementation",children:"DHT Implementation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Kademlia Integration"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct DHTNode {\n    routing_table: RoutingTable,\n    storage: Arc<RwLock<HashMap<Vec<u8>, Vec<u8>>>>,\n    network_id: NetworkId,\n}\n\nimpl DHTNode {\n    async fn handle_find_value(\n        &self,\n        key: Vec<u8>\n    ) -> Result<Option<Vec<u8>>, Error> {\n        // Check local storage first\n        if let Some(value) = self.storage.read().await.get(&key) {\n            return Ok(Some(value.clone()));\n        }\n        \n        // Query closest peers\n        let closest = self.routing_table.closest_peers(&key);\n        for peer in closest {\n            if let Some(value) = self.query_peer(peer, key.clone()).await? {\n                return Ok(Some(value));\n            }\n        }\n        \n        Ok(None)\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"integration",children:"Integration"}),"\n",(0,s.jsx)(n.h3,{id:"service-integration",children:"Service Integration"}),"\n",(0,s.jsx)(n.p,{children:"The P2P transport integrates with Runar services through the service registry:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"impl P2PTransport {\n    async fn forward_to_service(\n        &self,\n        service: &str,\n        request: ServiceRequest\n    ) -> Result<ServiceResponse, Error> {\n        let service = self.registry.get_service(service)?;\n        service.process_request(request).await\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"discovery-integration",children:"Discovery Integration"}),"\n",(0,s.jsx)(n.p,{children:"Integration with the Discovery mechanism:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"impl P2PTransport {\n    async fn handle_discovery_event(\n        &self,\n        event: DiscoveryEvent\n    ) -> Result<(), Error> {\n        match event {\n            DiscoveryEvent::PeerFound { peer_id, addr, networks } => {\n                for network_id in networks {\n                    if self.is_network_member(&network_id) {\n                        self.connect_to_peer(peer_id, network_id, addr.clone()).await?;\n                    }\n                }\n            }\n            DiscoveryEvent::PeerLost { peer_id } => {\n                self.remove_peer(peer_id).await?;\n            }\n        }\n        Ok(())\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This specification aligns with:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Keys Management Specification for PeerId and NetworkId definitions"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Discovery Mechanism Specification for peer discovery"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Service Architecture for message routing and processing"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.p,{children:"This section will be expanded with practical examples."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);
"use strict";(self.webpackChunkrunar_docs=self.webpackChunkrunar_docs||[]).push([[823],{291:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"services/example-service","title":"Example Service Implementation","description":"This document provides a complete example of a service implementation in the Runar node system, demonstrating both request-response and publish-subscribe patterns.","source":"@site/docs/services/example-service.md","sourceDirName":"services","slug":"/services/example-service","permalink":"/docs/services/example-service","draft":false,"unlisted":false,"editUrl":"https://github.com/runar-labs/runar-rust/tree/main/rust-docs/markdown/docs/services/example-service.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Services in Runar","permalink":"/docs/services/macros"},"next":{"title":"Runar Encryption Schema","permalink":"/docs/features/encryption-schema"}}');var a=t(4848),s=t(8453);const o={},i="Example Service Implementation",c={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Service Implementation with Macros",id:"service-implementation-with-macros",level:2},{value:"Benefits of the Macro Approach",id:"benefits-of-the-macro-approach",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"example-service-implementation",children:"Example Service Implementation"})}),"\n",(0,a.jsx)(n.p,{children:"This document provides a complete example of a service implementation in the Runar node system, demonstrating both request-response and publish-subscribe patterns."}),"\n",(0,a.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#service-implementation-with-macros",children:"Service Implementation with Macros"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#using-services",children:"Using Services"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#examples",children:"Examples"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(n.p,{children:"This document demonstrates how to implement services using the Runar service macros. The examples show both traditional manual implementations and the preferred macro approach."}),"\n",(0,a.jsx)(n.h2,{id:"service-implementation-with-macros",children:"Service Implementation with Macros"}),"\n",(0,a.jsxs)(n.p,{children:["Below is an example of a ",(0,a.jsx)(n.code,{children:"DataService"})," that manages data records, with operations to create, retrieve, update, and delete records, as well as publish events when records change. This example uses the service macros for a cleaner implementation."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use anyhow::{anyhow, Result};\nuse chrono::Utc;\nuse runar_node::services::RequestContext;\nuse runar_common::types::ArcValue;\nuse runar_node::vmap;\nuse runar_macros::{service, action, subscribe};\nuse serde::{Serialize, Deserialize};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\nuse uuid::Uuid;\n\n/// A data record with serialization support\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct DataRecord {\n    id: String,\n    name: String,\n    value: String,\n    created_at: String,\n    updated_at: String,\n}\n\nimpl DataRecord {\n    fn new(name: &str, value: &str) -> Self {\n        let now = Utc::now().to_rfc3339();\n        Self {\n            id: Uuid::new_v4().to_string(),\n            name: name.to_string(),\n            value: value.to_string(),\n            created_at: now.clone(),\n            updated_at: now,\n        }\n    }\n\n    fn update(&mut self, value: &str) {\n        self.value = value.to_string();\n        self.updated_at = Utc::now().to_rfc3339();\n    }\n\n    // Convert to ArcValue for event publishing\n    fn to_arc_value(&self) -> ArcValue {\n        ArcValue::from_struct(self.clone())\n    }\n}\n\nimpl From<DataRecord> for ArcValue {\n    fn from(record: DataRecord) -> Self {\n        ArcValue::from_struct(record)\n    }\n}\n\n/// DataService manages a collection of data records\n#[service(\n    name = "data",\n    path = "data_service",\n    description = "Service for managing data records",\n    version = "1.0.0"\n)]\nstruct DataService {\n    records: Arc<Mutex<HashMap<String, DataRecord>>>,\n}\n\n#[service_impl]\nimpl DataService {\n    pub fn new() -> Self {\n        DataService {\n            records: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n\n    // CRUD Operations using action macros\n    \n    // Create a new record - returns String (the record ID)\n    #[action(name = "create")]\n    async fn create_record(&self, context: &RequestContext, name: &str, value: &str) -> Result<String> {\n        let record = DataRecord::new(name, value);\n        let record_id = record.id.clone();\n        \n        // Store the record\n        {\n            let mut records = self.records.lock().await;\n            records.insert(record.id.clone(), record.clone());\n        }\n        \n        // Publish event that a record was created\n        context.publish(\n            &format!("{}/created", context.service_path()),\n            ArcValue::from_struct(record.clone())\n        ).await?;\n        \n        // Return just the record ID directly\n        Ok(record_id)\n    }\n    \n    // Get a record by ID - returns the DataRecord directly\n    #[action(name = "get")]\n    async fn get_record(&self, _context: &RequestContext, id: &str) -> Result<DataRecord> {\n        let records = self.records.lock().await;\n        \n        if let Some(record) = records.get(id) {\n            Ok(record.clone())\n        } else {\n            Err(anyhow!("Record with ID {} not found", id))\n        }\n    }\n    \n    // Update a record - returns the updated DataRecord\n    #[action(name = "update")]\n    async fn update_record(&self, context: &RequestContext, id: &str, value: &str) -> Result<DataRecord> {\n        let mut updated_record: Option<DataRecord> = None;\n        \n        // Update the record\n        {\n            let mut records = self.records.lock().await;\n            \n            if let Some(record) = records.get_mut(id) {\n                record.update(value);\n                updated_record = Some(record.clone());\n            }\n        }\n        \n        // Check if record was found and updated\n        if let Some(record) = updated_record {\n            // Publish event that a record was updated\n            context.publish(\n                &format!("{}/updated", context.service_path()),\n                ArcValue::from_struct(record.clone())\n            ).await?;\n            \n            Ok(record)\n        } else {\n            Err(anyhow!("Record with ID {} not found", id))\n        }\n    }\n    \n    // Delete a record - returns a boolean indicating success\n    #[action(name = "delete")]\n    async fn delete_record(&self, context: &RequestContext, id: &str) -> Result<bool> {\n        let deleted_record: Option<DataRecord>;\n        \n        // Delete the record\n        {\n            let mut records = self.records.lock().await;\n            deleted_record = records.remove(id);\n        }\n        \n        // Check if record was found and deleted\n        if let Some(record) = deleted_record {\n            // Publish event that a record was deleted\n            context.publish(\n                &format!("{}/deleted", context.service_path()),\n                ArcValue::from_struct(record.clone())\n            ).await?;\n            \n            Ok(true)\n        } else {\n            Err(anyhow!("Record with ID {} not found", id))\n        }\n    }\n    \n    // List all records - returns a Vec of DataRecord\n    #[action(name = "list")]\n    async fn list_records(&self, _context: &RequestContext) -> Result<Vec<DataRecord>> {\n        let records = self.records.lock().await;\n        let records_vec = records.values().cloned().collect();\n        Ok(records_vec)\n    }\n    \n    // Count records - returns a simple u32\n    #[action(name = "count")]\n    async fn count_records(&self, _context: &RequestContext) -> Result<u32> {\n        let records = self.records.lock().await;\n        Ok(records.len() as u32)\n    }\n}\n\n/// Service for monitoring data events\n#[service(\n    name = "monitor",\n    path = "data_monitor",\n    description = "Service for monitoring data events"\n)]\nstruct DataMonitorService {\n    // Statistics counters\n    stats: Arc<Mutex<HashMap<String, usize>>>,\n}\n\n#[service_impl]\nimpl DataMonitorService {\n    pub fn new() -> Self {\n        let mut stats = HashMap::new();\n        \n        // Initialize counters\n        stats.insert("created".to_string(), 0);\n        stats.insert("updated".to_string(), 0);\n        stats.insert("deleted".to_string(), 0);\n        stats.insert("total".to_string(), 0);\n        \n        DataMonitorService {\n            stats: Arc::new(Mutex::new(stats)),\n        }\n    }\n    \n    // Get all statistics - returns a HashMap directly\n    #[action(name = "get_stats")]\n    async fn get_stats(&self, _context: &RequestContext) -> Result<HashMap<String, usize>> {\n        let stats = self.stats.lock().await;\n        // Return a clone of the stats directly\n        Ok(stats.clone())\n    }\n    \n    // Event handlers for the various data events\n    #[subscribe(topic = "data_service/created")]\n    async fn on_record_created(&mut self, payload: ArcValue) -> Result<()> {\n        // Extract the record from the payload\n        let record: DataRecord = payload.as_type()?;\n        \n        // Update the statistics\n        let mut stats = self.stats.lock().await;\n        *stats.entry("created".to_string()).or_insert(0) += 1;\n        *stats.entry("total".to_string()).or_insert(0) += 1;\n        \n        println!("Record created: {}", record.id);\n        Ok(())\n    }\n    \n    #[subscribe(topic = "data_service/updated")]\n    async fn on_record_updated(&mut self, payload: ArcValue) -> Result<()> {\n        // Extract the record from the payload\n        let record: DataRecord = payload.as_type()?;\n        \n        // Update the statistics\n        let mut stats = self.stats.lock().await;\n        *stats.entry("updated".to_string()).or_insert(0) += 1;\n        \n        println!("Record updated: {}", record.id);\n        Ok(())\n    }\n    \n    #[subscribe(topic = "data_service/deleted")]\n    async fn on_record_deleted(&mut self, payload: ArcValue) -> Result<()> {\n        // Extract the record from the payload\n        let record: DataRecord = payload.as_type()?;\n        \n        // Update the statistics\n        let mut stats = self.stats.lock().await;\n        *stats.entry("deleted".to_string()).or_insert(0) += 1;\n        *stats.entry("total".to_string()).or_insert(0) -= 1;\n        \n        println!("Record deleted: {}", record.id);\n        Ok(())\n    }\n}\n\n// Required for subscription handlers\nimpl Clone for DataMonitorService {\n    fn clone(&self) -> Self {\n        Self {\n            stats: self.stats.clone(),\n        }\n    }\n}\n\n## Using Services\n\nHere\'s an example of how to use these services in a Runar node, demonstrating both direct parameter passing and map-based parameters:\n\n```rust\nuse anyhow::Result;\nuse runar_node::node::{Node, NodeConfig};\nuse runar_node::vmap;\nuse tokio;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    // Create and configure the node\n    let config = NodeConfig::new(\n        "my_node",\n        "./data",\n        "./data/db",\n    );\n    let mut node = Node::new(config).await?;\n    \n    // Initialize the node\n    node.init().await?;\n    \n    // Create and add the services\n    let data_service = DataService::new();\n    let monitor_service = DataMonitorService::new();\n    \n    node.add_service(data_service).await?;\n    node.add_service(monitor_service).await?;\n    node.start().await?;\n    \n    // Create a new data record using map-based parameters\n    let create_result = node.request(\n        "data_service/create",\n        vmap! {\n            "name" => "test_record",\n            "value" => "initial value"\n        },\n    ).await?;\n    \n    // The action returns a String directly\n    let record_id: String = create_result;\n    println!("Created record with ID: {}", record_id);\n    \n    // Update the record using map-based parameters\n    let updated_record = node.request(\n        "data_service/update",\n        vmap! {\n            "id" => record_id.clone(),\n            "value" => "updated value"\n        },\n    ).await?;\n    \n    println!("Updated record: {:?}", updated_record);\n    \n    // Count records - direct value extraction\n    let record_count: u32 = node.request("data_service/count", None).await?;\n    println!("Current record count: {}", record_count);\n    \n    // Get a record using direct parameter passing\n    // For actions with a single parameter, you can pass the value directly\n    let get_result = node.request(\n        "data_service/get",\n        record_id.clone(), // Direct string parameter without vmap!\n    ).await?;\n    \n    // The action returns a DataRecord directly\n    let record: DataRecord = get_result;\n    println!("Retrieved record - Name: {}, Value: {}", record.name, record.value);\n    \n    // Wait a bit for events to be processed\n    tokio::time::sleep(std::time::Duration::from_millis(100)).await;\n    \n    // Get statistics from the monitor service\n    let stats_result = node.request(\n        "data_monitor/get_stats",\n        vmap! {}, // Empty map for no parameters\n    ).await?;\n    \n    // The action returns a HashMap directly\n    let stats: HashMap<String, u32> = stats_result;\n    println!("Current stats: {:?}", stats);\n    \n    // Delete the record - this action takes a single string parameter\n    let delete_result = node.request(\n        "data_service/delete",\n        record_id, // Direct parameter without vmap!\n    ).await?;\n    \n    // The action returns a boolean directly  \n    let delete_success: bool = delete_result;\n    println!("Delete successful: {}", delete_success);\n    \n    // Wait for events to be processed\n    tokio::time::sleep(std::time::Duration::from_millis(100)).await;\n    \n    // Get final statistics\n    let final_stats = node.request(\n        "data_monitor/get_stats",\n        vmap! {},\n    ).await?;\n    \n    let final_stats: HashMap<String, u32> = final_stats;\n    println!("Final stats: {:?}", final_stats);\n    \n    // Gracefully shut down the node\n    node.stop().await?;\n    \n    Ok(())\n}\n\n## Examples\n\n### Key Differences with the Macro Approach\n\n1. **Direct Return Types**: Action methods return their actual data types (`String`, `DataRecord`, `u32`, etc.) instead of `ServiceResponse`.\n\n2. **Simplified Parameter Extraction**: The `vmap!` and specialized type macros are used for clean parameter extraction with defaults:\n   ```rust\n   // Instead of chained unwraps:\n   let record_id = create_result\n       .data\n       .and_then(|data| data.get("id"))\n       .and_then(|id| id.as_str().map(|s| s.to_string()))\n       .expect("Failed to get record ID");\n       \n   // With direct return types:\n   let record_id: String = create_result;\n'})}),"\n",(0,a.jsxs)(n.ol,{start:"3",children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Direct Parameter Passing"}),": For actions with a single parameter, you can pass the value directly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'// Instead of:\nnode.request("data_service/get", vmap! { "id" => record_id })\n\n// You can use:\nnode.request("data_service/get", record_id)\n'})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Clean Event Subscriptions"}),": The ",(0,a.jsx)(n.code,{children:"#[subscribe]"})," macro automatically sets up event subscriptions."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Automatic Error Handling"}),": Error responses are automatically generated from the ",(0,a.jsx)(n.code,{children:"Result<T>"})," return type."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"benefits-of-the-macro-approach",children:"Benefits of the Macro Approach"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Less Boilerplate"}),": No need to manually implement the ",(0,a.jsx)(n.code,{children:"AbstractService"})," trait"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Type Safety"}),": Action return types are preserved and automatically converted"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cleaner API"}),": Fewer lines of code for common operations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Better Error Handling"}),": Errors are propagated naturally through Rust's Result type"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Consistent Events"}),": Event publishing and subscription follow a standard pattern"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(6540);const a={},s=r.createContext(a);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);
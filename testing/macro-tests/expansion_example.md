# Macro Expansion Examples

This document shows the expanded code generated by the Runar macros. These examples demonstrate how the macros transform the input code into the actual implementation that gets compiled.

## Service Macro Expansion

When you apply the `#[service]` macro to a struct, it generates several trait implementations:

```rust
// Original code
#[service]
struct CounterService {
    counter: Arc<Mutex<i32>>,
}

// Expands to:
#[async_trait::async_trait]
impl runar_node::services::AbstractService for CounterService {
    fn name(&self) -> &str {
        "counter_service"
    }
    //NOTE: shuold not have / 
    //it shuold be "counter_service"
    fn path(&self) -> &str {
        "/counter_service"
    }
    fn description(&self) -> &str {
        "Service CounterService"
    }
    fn version(&self) -> &str {
        "0.1.0"
    }
    fn state(&self) -> runar_node::services::ServiceState {
        runar_node::services::ServiceState::Initialized
    }
    fn metadata(&self) -> runar_node::services::ServiceMetadata {
        runar_node::services::ServiceMetadata::new()
    }
    async fn init(
        &mut self,
        context: &runar_node::services::RequestContext,
    ) -> anyhow::Result<()> {
        self.setup_subscriptions(context).await?;
        Ok(())
    }
    async fn start(&mut self) -> anyhow::Result<()> {
        Ok(())
    }
    async fn stop(&mut self) -> anyhow::Result<()> {
        Ok(())
    }
    async fn handle_request(
        &self,
        request: runar_node::services::ServiceRequest,
    ) -> anyhow::Result<runar_node::services::ServiceResponse> {
        let operation = &request.operation;
        let params = request.params.unwrap_or(runar_common::types::ValueType::Null);
        let context = &request.context;
        let service_ref: &dyn std::any::Any = self;
        let handlers = crate::action_registry::get_action_handlers();
        let type_id = std::any::TypeId::of::<CounterService>();

        //NOTE: That is not the correct flow.. here u get the action handler from the registry
        //and u match the service and acrtion her.. that is not correct.. in here
        //all u need to do is to delegate to the local methods of the CounterService
        
        for handler in handlers {
            if handler.service_type_id == type_id && handler.name == operation {
                return (handler.handler_fn)(service_ref, context, operation, params)
                    .await
                    .map_err(|e| anyhow::anyhow!("Error executing action: {}", e));
            }
        }
        Err(anyhow::anyhow!("Unknown operation: {}", operation))
    }
}

impl CounterService {
    async fn setup_subscriptions(
        &self,
        context: &runar_node::services::RequestContext,
    ) -> anyhow::Result<()> {
        let handlers = crate::subscription_registry::get_subscription_handlers();
        let service_ref: &dyn std::any::Any = self;
        for handler in handlers {
            (handler.register_fn)(service_ref, context).await?;
        }
        Ok(())
    }
}

impl runar_common::ServiceInfo for CounterService {
    fn service_name(&self) -> &str {
        "counter_service"
    }
    fn service_path(&self) -> &str {
        //NOET: incorrect should be "counter_service"
        "/counter_service"
    }
    fn service_description(&self) -> &str {
        "Service CounterService"
    }
    fn service_version(&self) -> &str {
        "0.1.0"
    }
}
```

## Action Macro Expansion

The `#[action]` macro transforms methods into action handlers:

```rust
// Original code
#[action]
async fn increment(&self, amount: i32) -> i32 {
    let mut counter = self.counter.lock().unwrap();
    *counter += amount;
    *counter
}

// Expands to action registry entries and handler implementation
// 1. It registers the action in a global registry during initialization
// 2. It implements the handler function that deserializes parameters and calls the method
// 3. It serializes the return value into a ServiceResponse
```

## Subscribe Macro Expansion

The `#[subscribe]` macro transforms methods into event handlers:

```rust
// Original code
#[subscribe("counter.updated")]
async fn on_counter_updated(&self, value: ValueType) {
    info!("Counter updated to: {}", value.as_i64().unwrap());
}

// Expands to subscription registry entries and handler implementation
// 1. It registers the subscription handler in a global registry
// 2. It implements the setup code to subscribe to the specified topic
// 3. It creates a callback that calls the method when events are received
```

## Key Observations

1. **Service State Management**: The service macro handles the service lifecycle, including initialization, starting, and stopping.

2. **Dynamic Dispatch**: The action handling uses dynamic dispatch through the `Any` trait to locate and call the appropriate handler function.

3. **Subscription Setup**: The service automatically sets up all registered subscriptions during initialization.

4. **Type Safety**: While the macros provide a dynamic interface externally, they maintain type safety through properly typed internal function calls.

5. **Error Handling**: The macro-generated code includes proper error handling and propagation using the `anyhow` crate.

These expansions demonstrate how the macros provide a clean, declarative API while generating the necessary boilerplate code to integrate with the Node system. 